<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Stephane Maldini, Simon Baslé">
<title>Reactor 3 参考指南</title>
<style>
@import url(https://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/1.6.2/semantic.min.css);


#header .details br+span.author:before {
    content: "\00a0\0026\00a0";
    color: rgba(0,0,0,.85);
}

#header .details br+span.email:before {
    content: "(";
}

#header .details br+span.email:after {
    content: ")";
}

/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
@import url(https://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.css);

article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary {
    display: block;
}

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video {
    display: inline-block;
}

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) {
    display: none;
    height: 0;
}

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template {
    display: none;
}

script {
    display: none !important;
}

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html {
    font-family: sans-serif; /* 1 */
    -ms-text-size-adjust: 100%; /* 2 */
    -webkit-text-size-adjust: 100%; /* 2 */
}

/** Remove default margin. */
body {
    margin: 0;
}

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a {
    background: transparent;
}

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus {
    outline: thin dotted;
}

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover {
    outline: 0;
}

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 {
    font-size: 2em;
    margin: 1.2em 0;
}

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] {
    border-bottom: 1px dotted;
}

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong {
    font-weight: bold;
}

/** Address styling not present in Safari 5 and Chrome. */
dfn {
    font-style: italic;
}

/** Address differences between Firefox and other browsers. */
hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/** Address styling not present in IE 8/9. */
mark {
    background: #ff0;
    color: #000;
}

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp {
    font-family: monospace, serif;
    font-size: 1em;
}

/** Improve readability of pre-formatted text in all browsers. */
pre {
    white-space: pre-wrap;
}

/** Set consistent quote types. */
q {
    quotes: "\201C" "\201D" "\2018" "\2019";
}

/** Address inconsistent and variable font size in all browsers. */
small {
    font-size: 80%;
}

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img {
    border: 0;
}

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) {
    overflow: hidden;
}

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure {
    margin: 0;
}

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend {
    border: 0; /* 1 */
    padding: 0; /* 2 */
}

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 2 */
    margin: 0; /* 3 */
}

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input {
    line-height: normal;
}

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select {
    text-transform: none;
}

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
}

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] {
    cursor: default;
}

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
}

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

meta.foundation-mq-small {
    font-family: "only screen and (min-width: 768px)";
    width: 768px;
}

meta.foundation-mq-medium {
    font-family: "only screen and (min-width:1280px)";
    width: 1280px;
}

meta.foundation-mq-large {
    font-family: "only screen and (min-width:1440px)";
    width: 1440px;
}

*, *:before, *:after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}

html, body {
    font-size: 100%;
}

body {
    background: white;
    color: #34302d;
    padding: 0;
    margin: 0;
    font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    line-height: 1.8em;
    position: relative;
    cursor: auto;
}

#content, #content p {
    line-height: 1.8em;
    margin-top: 1.5em;
}

#content li p {
  margin-top: 0.25em;
}

a:hover {
    cursor: pointer;
}

img, object, embed {
    max-width: 100%;
    height: auto;
}

object, embed {
    height: 100%;
}

img {
    -ms-interpolation-mode: bicubic;
}

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object {
    max-width: none !important;
}

.left {
    float: left !important;
}

.right {
    float: right !important;
}

.text-left {
    text-align: left !important;
}

.text-right {
    text-align: right !important;
}

.text-center {
    text-align: center !important;
}

.text-justify {
    text-align: justify !important;
}

.hide {
    display: none;
}

.antialiased, body {
    -webkit-font-smoothing: antialiased;
}

img {
    display: inline-block;
    vertical-align: middle;
}

textarea {
    height: auto;
    min-height: 50px;
}

select {
    width: 100%;
}

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: 1.21875em;
}

.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption {
    color: #6db33f;
    font-weight: 300;
    margin-top: 0.2em;
    margin-bottom: 0.5em;
}

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td {
    margin: 0;
    padding: 0;
    direction: ltr;
}

/* Default Link Styles */
a {
    color: #6db33f;
    line-height: inherit;
    text-decoration: none;
}

a:hover, a:focus {
    color: #6db33f;
    text-decoration: underline;
}

a img {
    border: none;
}

/* Default paragraph styles */
p {
    font-family: inherit;
    font-weight: normal;
    font-size: 1em;
    margin-bottom: 1.25em;
    text-rendering: optimizeLegibility;
}

p aside {
    font-size: 0.875em;
    font-style: italic;
}

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    font-family: "Montserrat", Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    color: #34302d;
    text-rendering: optimizeLegibility;
    margin-top: 1.6em;
    margin-bottom: 0.6em;
}

h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small {
    font-size: 60%;
    color: #6db33f;
    line-height: 0;
}

h1 {
    font-size: 2.125em;
}

h2 {
    font-size: 1.6875em;
}

h3, #toctitle, .sidebarblock > .content > .title {
    font-size: 1.375em;
}

h4 {
    font-size: 1.125em;
}

h5 {
    font-size: 1.125em;
}

h6 {
    font-size: 1em;
}

hr {
    border: solid #dcd2c9;
    border-width: 1px 0 0;
    clear: both;
    margin: 1.25em 0 1.1875em;
    height: 0;
}

/* Helpful Typography Defaults */
em, i {
    font-style: italic;
    line-height: inherit;
}

strong, b {
    font-weight: bold;
    line-height: inherit;
}

small {
    font-size: 60%;
    line-height: inherit;
}

code {
    font-family: Consolas, "Liberation Mono", Courier, monospace;
    font-weight: bold;
    color: #305CB5;
}

/* Lists */
ul, ol, dl {
    font-size: 1em;
    margin-bottom: 1.25em;
    list-style-position: outside;
    font-family: inherit;
}

ul, ol {
    margin-left: 1.5em;
}

ul.no-bullet, ol.no-bullet {
    margin-left: 1.5em;
}

/* Unordered Lists */
ul li ul, ul li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
    font-size: 1em; /* Override nested font-size change */
}

ul.square li ul, ul.circle li ul, ul.disc li ul {
    list-style: inherit;
}

ul.square {
    list-style-type: square;
}

ul.circle {
    list-style-type: circle;
}

ul.disc {
    list-style-type: disc;
}

ul.no-bullet {
    list-style: none;
}

/* Ordered Lists */
ol li ul, ol li ol {
    margin-left: 1.25em;
    margin-bottom: 0;
}

/* Definition Lists */
dl dt {
    margin-bottom: 0.3125em;
    font-weight: bold;
}

dl dd {
    margin-bottom: 1.25em;
}

/* Abbreviations */
abbr, acronym {
    text-transform: uppercase;
    font-size: 90%;
    color: #34302d;
    border-bottom: 1px dotted #dddddd;
    cursor: help;
}

abbr {
    text-transform: none;
}

/* Blockquotes */
blockquote {
    margin: 0 0 1.25em;
    padding: 0.5625em 1.25em 0 1.1875em;
    border-left: 1px solid #dddddd;
}

blockquote cite {
    display: block;
    font-size: 0.8125em;
    color: #655241;
}

blockquote cite:before {
    content: "\2014 \0020";
}

blockquote cite a, blockquote cite a:visited {
    color: #655241;
}

blockquote, blockquote p {
    color: #34302d;
}

/* Microformats */
.vcard {
    display: inline-block;
    margin: 0 0 1.25em 0;
    border: 1px solid #dddddd;
    padding: 0.625em 0.75em;
}

.vcard li {
    margin: 0;
    display: block;
}

.vcard .fn {
    font-weight: bold;
    font-size: 0.9375em;
}

.vevent .summary {
    font-weight: bold;
}

.vevent abbr {
    cursor: auto;
    text-decoration: none;
    font-weight: bold;
    border: none;
    padding: 0 0.0625em;
}

@media only screen and (min-width: 768px) {
    h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 {
    }

    h1 {
        font-size: 2.75em;
    }

    h2 {
        font-size: 2.3125em;
    }

    h3, #toctitle, .sidebarblock > .content > .title {
        font-size: 1.6875em;
    }

    h4 {
        font-size: 1.4375em;
    }
}

/* Print styles.  Inlined to avoid required HTTP connection: www.phpied.com/delay-loading-your-print-css/ Credit to Paul Irish and HTML5 Boilerplate (html5boilerplate.com)
*/
.print-only {
    display: none !important;
}

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a, a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
        content: "";
    }

    pre, blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr, img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p, h2, h3, #toctitle, .sidebarblock > .content > .title {
        orphans: 3;
        widows: 3;
    }

    h2, h3, #toctitle, .sidebarblock > .content > .title {
        page-break-after: avoid;
    }

    .hide-on-print {
        display: none !important;
    }

    .print-only {
        display: block !important;
    }

    .hide-for-print {
        display: none !important;
    }

    .show-for-print {
        display: inherit !important;
    }
}

/* Tables */
table {
    background: white;
    margin-bottom: 1.25em;
    border: solid 1px #34302d;
}

table thead, table tfoot {
    font-weight: bold;
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
    padding: 0.5em 0.625em 0.625em;
    font-size: inherit;
    color: #34302d;
    text-align: left;
}

table thead tr th {
    color: white;
    background: #34302d;
}

table tr th, table tr td {
    padding: 0.5625em 0.625em;
    font-size: inherit;
    color: #34302d;
    border: 0 none;
}

table tr.even, table tr.alt, table tr:nth-of-type(even) {
    background: #f2F2F2;
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
    display: table-cell;
}

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after {
    content: " ";
    display: table;
}

.clearfix:after, .float-group:after {
    clear: both;
}

*:not(pre) > code {
    font-size: inherit;
    padding: 0;
    white-space: nowrap;
    background-color: inherit;
    border: 0 solid #dddddd;
    -webkit-border-radius: 6px;
    border-radius: 6px;
    text-shadow: none;
}

pre, pre > code {
    color: black;
    font-family: monospace, serif;
    font-weight: normal;
}

.keyseq {
    color: #774417;
}

kbd:not(.keyseq) {
    display: inline-block;
    color: #211306;
    font-size: 0.75em;
    background-color: #F7F7F7;
    border: 1px solid #ccc;
    -webkit-border-radius: 3px;
    border-radius: 3px;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset;
    margin: -0.15em 0.15em 0 0.15em;
    padding: 0.2em 0.6em 0.2em 0.5em;
    vertical-align: middle;
    white-space: nowrap;
}

.keyseq kbd:first-child {
    margin-left: 0;
}

.keyseq kbd:last-child {
    margin-right: 0;
}

.menuseq, .menu {
    color: black;
}

b.button:before, b.button:after {
    position: relative;
    top: -1px;
    font-weight: normal;
}

b.button:before {
    content: "[";
    padding: 0 3px 0 2px;
}

b.button:after {
    content: "]";
    padding: 0 2px 0 3px;
}

p a > code:hover {
    color: #541312;
}

#header, #content, #footnotes, #footer {
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 0;
    margin-bottom: 0;
    max-width: 62.5em;
    *zoom: 1;
    position: relative;
    padding-left: 4em;
    padding-right: 4em;
}

#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after {
    content: " ";
    display: table;
}

#header:after, #content:after, #footnotes:after, #footer:after {
    clear: both;
}

#header {
    margin-bottom: 2.5em;
}

#header > h1 {
    color: #34302d;
    font-weight: 400;
}

#header span {
    color: #34302d;
}

#header #revnumber {
    text-transform: capitalize;
}

#header br {
    display: none;
}

#header br + span {
}

#revdate {
    display: block;
}

#toc {
    border-bottom: 1px solid #e6dfd8;
    padding-bottom: 1.25em;
}

#toc > ul {
    margin-left: 0.25em;
}

#toc ul.sectlevel0 > li > a {
    font-style: italic;
}

#toc ul.sectlevel0 ul.sectlevel1 {
    margin-left: 0;
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}

#toc ul {
    list-style-type: none;
}

#toctitle {
    color: #385dbd;
}

@media only screen and (min-width: 768px) {
    body.toc2 {
        padding-left: 15em;
        padding-right: 0;
    }

    #toc.toc2 {
        position: fixed;
        width: 15em;
        left: 0;
        border-bottom: 0;
        z-index: 1000;
        padding: 1em;
        height: 100%;
        top: 0px;
        background: #F1F1F1;
        overflow: auto;

        -moz-transition-property: top;
        -o-transition-property: top;
        -webkit-transition-property: top;
        transition-property: top;
        -moz-transition-duration: 0.4s;
        -o-transition-duration: 0.4s;
        -webkit-transition-duration: 0.4s;
        transition-duration: 0.4s;
    }

    #reactor-header {
        position: fixed;
        top: -75px;
        left: 0;
        right: 0;
        height: 75px;


        -moz-transition-property: top;
        -o-transition-property: top;
        -webkit-transition-property: top;
        transition-property: top;
        -moz-transition-duration: 0.4s;
        -o-transition-duration: 0.4s;
        -webkit-transition-duration: 0.4s;
        transition-duration: 0.4s;
    }

    body.head-show #toc.toc2 {
        top: 75px;
    }
    body.head-show #reactor-header {
        top: 0;
    }

    #toc.toc2 a {
        color: #34302d;
        font-family: Montserrat;
    }

    #toc.toc2 #toctitle {
        margin-top: 0;
        font-size: 1.2em;
    }

    #toc.toc2 > ul {
        font-size: .90em;
    }

    #toc.toc2 ul ul {
        margin-left: 0;
        padding-left: 0.4em;
    }

    #toc.toc2 ul.sectlevel0 ul.sectlevel1 {
        padding-left: 0;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 15em;
    }

    body.toc2.toc-right #toc.toc2 {
        border-right: 0;
        border-left: 1px solid #e6dfd8;
        left: auto;
        right: 0;
    }
}

@media only screen and (min-width: 1280px) {
    body.toc2 {
        padding-left: 20em;
        padding-right: 0;
    }

    #toc.toc2 {
        width: 20em;
    }

    #toc.toc2 #toctitle {
        font-size: 1.375em;
    }

    #toc.toc2 > ul {
        font-size: 0.95em;
    }

    #toc.toc2 ul ul {
        padding-left: 1.25em;
    }

    body.toc2.toc-right {
        padding-left: 0;
        padding-right: 20em;
    }
}

#content #toc {
    border-style: solid;
    border-width: 1px;
    border-color: #d9d9d9;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: #f2f2f2;
    border-width: 0;
    -webkit-border-radius: 6px;
    border-radius: 6px;
}

#content #toc > :first-child {
    margin-top: 0;
}

#content #toc > :last-child {
    margin-bottom: 0;
}

#content #toc a {
    text-decoration: none;
}

#content #toctitle {
    font-weight: bold;
    font-family: "Montserrat", Arial, sans-serif;
    font-size: 1em;
    padding-left: 0.125em;
}

#footer {
    max-width: 100%;
    background-color: white;
    padding: 1.25em;
    color: #CCC;
    border-top: 3px solid #F1F1F1;
}

#footer-text {
    color: #444;
    line-height: 1.44;
}

.sect1 {
    padding-bottom: 1.25em;
}

.sect1 + .sect1 {
    border-top: 1px solid #e6dfd8;
}

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor {
    position: absolute;
    width: 1em;
    margin-left: -1em;
    display: block;
    text-decoration: none;
    visibility: hidden;
    text-align: center;
    font-weight: normal;
}

#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before {
    content: '\00A7';
    font-size: .85em;
    vertical-align: text-top;
    display: block;
    margin-top: 0.05em;
}

#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover {
    visibility: visible;
}

#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link {
    color: #34302d;
    text-decoration: none;
}

#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover {
    color: #34302d;
}

.imageblock, .literalblock, .listingblock, .mathblock, .verseblock, .videoblock {
    margin-bottom: 1.25em;
    margin-top: 1.25em;
}

.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .mathblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title {
    text-align: left;
    font-weight: bold;
}

.tableblock > caption {
    text-align: left;
    font-weight: bold;
    white-space: nowrap;
    overflow: visible;
    max-width: 0;
}

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p {
    font-size: inherit;
}

.admonitionblock > table {
    border: 0;
    background: none;
    width: 100%;
}

.admonitionblock > table td.icon {
    text-align: center;
    width: 80px;
}

.admonitionblock > table td.icon img {
    max-width: none;
}

.admonitionblock > table td.icon .title {
    font-weight: bold;
    text-transform: uppercase;
}

.admonitionblock > table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #dcd2c9;
    color: #34302d;
}

.admonitionblock > table td.content > :last-child > :last-child {
    margin-bottom: 0;
}

.exampleblock > .content {
    border-style: solid;
    border-width: 1px;
    border-color: #f3e0ce;
    margin-bottom: 1.25em;
    padding: 1.25em;
    background: white;
    -webkit-border-radius: 6px;
    border-radius: 6px;
}

.exampleblock > .content > :first-child {
    margin-top: 0;
}

.exampleblock > .content > :last-child {
    margin-bottom: 0;
}

.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p {
    color: #333333;
}

.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 {
    margin-bottom: 0.625em;
}

.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader {
}

.exampleblock.result > .content {
    -webkit-box-shadow: 0 1px 8px #d9d9d9;
    box-shadow: 0 1px 8px #d9d9d9;
}

.sidebarblock {
    padding: 1.25em 2em;
    background: #F1F1F1;
    margin: 2em -2em;

}

.sidebarblock > :first-child {
    margin-top: 0;
}

.sidebarblock > :last-child {
    margin-bottom: 0;
}

.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p {
    color: #333333;
}

.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 {
    margin-bottom: 0.625em;
}

.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader {
}

.sidebarblock > .content > .title {
    color: #6db33f;
    margin-top: 0;
    font-size: 1.2em;
}

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child {
    margin-bottom: 0;
}

/*.literalblock .content pre.highlight, .listingblock .content pre.highlight {*/
    /*background-color: #f1f8ec;*/
/*}*/
/*.literalblock pre:not([class]), .listingblock pre:not([class]) {*/
    /*background-color: #f1f8ec;*/
/*}*/

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
    border-width: 1px;
    border-style: solid;
    border-color: rgba(21, 35, 71, 0.1);
    -webkit-border-radius: 6px;
    border-radius: 6px;
    padding: 0.8em;
    word-wrap: break-word;
}

.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap {
    overflow-x: auto;
    white-space: pre;
    word-wrap: normal;
}

.literalblock pre > code, .literalblock pre[class] > code, .listingblock pre > code, .listingblock pre[class] > code {
    display: block;
}

@media only screen {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.72em;
    }
}

@media only screen and (min-width: 768px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.81em;
    }
}

@media only screen and (min-width: 1280px) {
    .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] {
        font-size: 0.9em;
    }
}

.listingblock pre.highlight {
    padding: 0;
    line-height: 1em;
}

.listingblock pre.highlight > code {
    padding: 0.8em;
}

.listingblock > .content {
    position: relative;
}

.listingblock:hover code[class*=" language-"]:before {
    text-transform: uppercase;
    font-size: 0.9em;
    color: #999;
    position: absolute;
    top: 0.375em;
    right: 0.375em;
}

.listingblock:hover code.asciidoc:before {
    content: "asciidoc";
}

.listingblock:hover code.clojure:before {
    content: "clojure";
}

.listingblock:hover code.css:before {
    content: "css";
}

.listingblock:hover code.groovy:before {
    content: "groovy";
}

.listingblock:hover code.html:before {
    content: "html";
}

.listingblock:hover code.java:before {
    content: "java";
}

.listingblock:hover code.javascript:before {
    content: "javascript";
}

.listingblock:hover code.python:before {
    content: "python";
}

.listingblock:hover code.ruby:before {
    content: "ruby";
}

.listingblock:hover code.sass:before {
    content: "sass";
}

.listingblock:hover code.scss:before {
    content: "scss";
}

.listingblock:hover code.xml:before {
    content: "xml";
}

.listingblock:hover code.yaml:before {
    content: "yaml";
}

.listingblock.terminal pre .command:before {
    content: attr(data-prompt);
    padding-right: 0.5em;
    color: #999;
}

.listingblock.terminal pre .command:not([data-prompt]):before {
    content: '$';
}

table.pyhltable {
    border: 0;
    margin-bottom: 0;
}

table.pyhltable td {
    vertical-align: top;
    padding-top: 0;
    padding-bottom: 0;
}

table.pyhltable td.code {
    padding-left: .75em;
    padding-right: 0;
}

.highlight.pygments .lineno, table.pyhltable td:not(.code) {
    color: #999;
    padding-left: 0;
    padding-right: .5em;
    border-right: 1px solid #dcd2c9;
}

.highlight.pygments .lineno {
    display: inline-block;
    margin-right: .25em;
}

table.pyhltable .linenodiv {
    background-color: transparent !important;
    padding-right: 0 !important;
}

.quoteblock {
    margin: 0 0 1.25em;
    padding: 0.5625em 1.25em 0 1.1875em;
    border-left: 3px solid #dddddd;
}

.quoteblock blockquote {
    margin: 0 0 1.25em 0;
    padding: 0 0 0.5625em 0;
    border: 0;
}

.quoteblock blockquote > .paragraph:last-child p {
    margin-bottom: 0;
}

.quoteblock .attribution {
    margin-top: -.25em;
    padding-bottom: 0.5625em;
    font-size: 0.8125em;
}

.quoteblock .attribution br {
    display: none;
}

.quoteblock .attribution cite {
    display: block;
    margin-bottom: 0.625em;
}

table thead th, table tfoot th {
    font-weight: bold;
}

table.tableblock.grid-all {
    border-collapse: separate;
    border-radius: 6px;
    border-top: 1px solid #34302d;
    border-bottom: 1px solid #34302d;
}

table.tableblock.frame-topbot, table.tableblock.frame-none {
    border-left: 0;
    border-right: 0;
}

table.tableblock.frame-sides, table.tableblock.frame-none {
    border-top: 0;
    border-bottom: 0;
}

table.tableblock td .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child {
    margin-bottom: 0;
}

th.tableblock.halign-left, td.tableblock.halign-left {
    text-align: left;
}

th.tableblock.halign-right, td.tableblock.halign-right {
    text-align: right;
}

th.tableblock.halign-center, td.tableblock.halign-center {
    text-align: center;
}

th.tableblock.valign-top, td.tableblock.valign-top {
    vertical-align: top;
}

th.tableblock.valign-bottom, td.tableblock.valign-bottom {
    vertical-align: bottom;
}

th.tableblock.valign-middle, td.tableblock.valign-middle {
    vertical-align: middle;
}

tbody tr th {
    display: table-cell;
    background: rgba(105, 60, 22, 0.25);
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
    color: #211306;
    font-weight: bold;
}

td > div.verse {
    white-space: pre;
}

ol {
    margin-left: 1.75em;
}

ul li ol {
    margin-left: 1.5em;
}

dl dd {
    margin-left: 1.125em;
}

dl dd:last-child, dl dd:last-child > :last-child {
    margin-bottom: 0;
}

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist {
    margin-bottom: 0.625em;
}

ul.unstyled, ol.unnumbered, ul.checklist, ul.none {
    list-style-type: none;
}

ul.unstyled, ol.unnumbered, ul.checklist {
    margin-left: 0.625em;
}

ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    margin-right: 0.25em;
}

ul.checklist li > p:first-child > input[type="checkbox"]:first-child {
    position: relative;
    top: 1px;
}

ul.inline {
    margin: 0 auto 0.625em auto;
    margin-left: -1.375em;
    margin-right: 0;
    padding: 0;
    list-style: none;
    overflow: hidden;
}

ul.inline > li {
    list-style: none;
    float: left;
    margin-left: 1.375em;
    display: block;
}

ul.inline > li > * {
    display: block;
}

.unstyled dl dt {
    font-weight: normal;
    font-style: normal;
}

ol.arabic {
    list-style-type: decimal;
}

ol.decimal {
    list-style-type: decimal-leading-zero;
}

ol.loweralpha {
    list-style-type: lower-alpha;
}

ol.upperalpha {
    list-style-type: upper-alpha;
}

ol.lowerroman {
    list-style-type: lower-roman;
}

ol.upperroman {
    list-style-type: upper-roman;
}

ol.lowergreek {
    list-style-type: lower-greek;
}

.hdlist > table, .colist > table {
    border: 0;
    background: none;
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
    background: none;
}

td.hdlist1 {
    padding-right: .75em;
    font-weight: bold;
}

td.hdlist1, td.hdlist2 {
    vertical-align: top;
}

.literalblock + .colist, .listingblock + .colist {
    margin-top: -0.5em;
}

.colist > table tr > td:first-of-type {
    padding: 0 .75em;
}

.colist > table tr > td:last-of-type {
    padding: 0.25em 0;
}

.qanda > ol > li > p > em:only-child {
    color: #063f40;
}

.thumb, .th {
    line-height: 0;
    display: inline-block;
    border: solid 4px white;
    -webkit-box-shadow: 0 0 0 1px #dddddd;
    box-shadow: 0 0 0 1px #dddddd;
}

.imageblock.left, .imageblock[style*="float: left"] {
    margin: 0.25em 0.625em 1.25em 0;
}

.imageblock.right, .imageblock[style*="float: right"] {
    margin: 0.25em 0 1.25em 0.625em;
}

.imageblock > .title {
    margin-bottom: 0;
}

.imageblock.thumb, .imageblock.th {
    border-width: 6px;
}

.imageblock.thumb > .title, .imageblock.th > .title {
    padding: 0 0.125em;
}

.image.left, .image.right {
    margin-top: 0.25em;
    margin-bottom: 0.25em;
    display: inline-block;
    line-height: 0;
}

.image.left {
    margin-right: 0.625em;
}

.image.right {
    margin-left: 0.625em;
}

a.image {
    text-decoration: none;
}

span.footnote, span.footnoteref {
    vertical-align: super;
    font-size: 0.875em;
}

span.footnote a, span.footnoteref a {
    text-decoration: none;
}

#footnotes {
    padding-top: 0.75em;
    padding-bottom: 0.75em;
    margin-bottom: 0.625em;
}

#footnotes hr {
    width: 20%;
    min-width: 6.25em;
    margin: -.25em 0 .75em 0;
    border-width: 1px 0 0 0;
}

#footnotes .footnote {
    padding: 0 0.375em;
    font-size: 0.875em;
    margin-left: 1.2em;
    text-indent: -1.2em;
    margin-bottom: .2em;
}

#footnotes .footnote a:first-of-type {
    font-weight: bold;
    text-decoration: none;
}

#footnotes .footnote:last-of-type {
    margin-bottom: 0;
}

#content #footnotes {
    margin-top: -0.625em;
    margin-bottom: 0;
    padding: 0.75em 0;
}

.gist .file-data > table {
    border: none;
    background: #fff;
    width: 100%;
    margin-bottom: 0;
}

.gist .file-data > table td.line-data {
    width: 99%;
}

div.unbreakable {
    page-break-inside: avoid;
}

.big {
    font-size: larger;
}

.small {
    font-size: smaller;
}

.underline {
    text-decoration: underline;
}

.overline {
    text-decoration: overline;
}

.line-through {
    text-decoration: line-through;
}

.aqua {
    color: #00bfbf;
}

.aqua-background {
    background-color: #00fafa;
}

.black {
    color: black;
}

.black-background {
    background-color: black;
}

.blue {
    color: #0000bf;
}

.blue-background {
    background-color: #0000fa;
}

.fuchsia {
    color: #bf00bf;
}

.fuchsia-background {
    background-color: #fa00fa;
}

.gray {
    color: #606060;
}

.gray-background {
    background-color: #7d7d7d;
}

.green {
    color: #006000;
}

.green-background {
    background-color: #007d00;
}

.lime {
    color: #00bf00;
}

.lime-background {
    background-color: #00fa00;
}

.maroon {
    color: #600000;
}

.maroon-background {
    background-color: #7d0000;
}

.navy {
    color: #000060;
}

.navy-background {
    background-color: #00007d;
}

.olive {
    color: #606000;
}

.olive-background {
    background-color: #7d7d00;
}

.purple {
    color: #600060;
}

.purple-background {
    background-color: #7d007d;
}

.red {
    color: #bf0000;
}

.red-background {
    background-color: #fa0000;
}

.silver {
    color: #909090;
}

.silver-background {
    background-color: #bcbcbc;
}

.teal {
    color: #006060;
}

.teal-background {
    background-color: #007d7d;
}

.white {
    color: #bfbfbf;
}

.white-background {
    background-color: #fafafa;
}

.yellow {
    color: #bfbf00;
}

.yellow-background {
    background-color: #fafa00;
}

span.icon > [class^="icon-"], span.icon > [class*=" icon-"] {
    cursor: default;
}

.admonitionblock td.icon [class^="icon-"]:before {
    font-size: 2.5em;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    cursor: default;
}

.admonitionblock td.icon .icon-note:before {
    content: "\f05a";
    color: #095557;
    color: #064042;
}

.admonitionblock td.icon .icon-tip:before {
    content: "\f0eb";
    text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8);
    color: #111;
}

.admonitionblock td.icon .icon-warning:before {
    content: "\f071";
    color: #bf6900;
}

.admonitionblock td.icon .icon-caution:before {
    content: "\f06d";
    color: #bf3400;
}

.admonitionblock td.icon .icon-important:before {
    content: "\f06a";
    color: #bf0000;
}

.conum {
    display: inline-block;
    color: white !important;
    background-color: #6db33f;
    -webkit-border-radius: 100px;
    border-radius: 100px;
    text-align: center;
    width: 20px;
    height: 20px;
    font-size: 12px;
    font-weight: bold;
    line-height: 20px;
    font-family: Arial, sans-serif;
    font-style: normal;
    position: relative;
    top: -2px;
    letter-spacing: -1px;
}

.conum * {
    color: white !important;
}

.conum + b {
    display: none;
}

.conum:after {
    content: attr(data-value);
}

.conum:not([data-value]):empty {
    display: none;
}

body {
    padding-top: 60px;
}

#toc.toc2 ul ul {
    padding-left: 1em;
}
#toc.toc2 ul ul.sectlevel2 {
}

#toctitle {
    color: #34302d;
    display: none;
}

#header h1 {
    font-weight: bold;
    position: relative;
    left: -0.0625em;
}

#header h1 span.lo {
    color: #dc9424;
}

#content h2, #content h3, #content #toctitle, #content .sidebarblock > .content > .title, #content h4, #content h5, #content #toctitle {
    font-weight: normal;
    position: relative;
    left: -0.0625em;
}

#content h2 {
    font-weight: bold;
}

.admonitionblock > table td.content {
    border-color: #e6dfd8;
}

table.tableblock.grid-all {
    -webkit-border-radius: 0;
    border-radius: 0;
}

#footer {
    background-color: white;
    color: #34302d;
}

.imageblock .title {
    text-align: center;
}

#content h1.sect0 {
    font-size: 48px;
}

#toc > ul > li > a {
    font-size: large;
}




@import url(https://fonts.googleapis.com/css?family=Montserrat:400,700|Karla:400,700);
body {
}
#reactor-header {
    background: #34302d;
    border-top: 4px solid #6db33f;
    z-index: 2000;
    font-family: 'Montserrat';
    height: 75px;
}

#reactor-header h1#logo {
    margin: 7px 0 0 10px;
    padding: 0;
    float: left;
}

#reactor-header h1#logo a {
    display: block;
    background: url(images/logo-2x.png) no-repeat 0 0;
    background-size: 253px 80px;
    height: 40px;
    width: 253px;
    text-indent: -6000em;
    margin: 8px 0;
}
#reactor-header h1#logo a:hover strong {
    filter: progid:DXImageTransform.Microsoft.Alpha(enabled=false);
    opacity: 1;
}
#reactor-header h1#logo a strong {
    display: block;
    background: url(images/logo-2x.png) no-repeat 0 0;
    background-size: 253px 80px;
    color: red;
    height: 40px;
    width: 253px;
    text-indent: -6000em;
    margin: 8px 0;
    -moz-transition-property: opacity;
    -o-transition-property: opacity;
    -webkit-transition-property: opacity;
    transition-property: opacity;
    -moz-transition-duration: 0.2s;
    -o-transition-duration: 0.2s;
    -webkit-transition-duration: 0.2s;
    transition-duration: 0.2s;
    filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=0);
    opacity: 0;
}

#nav, #nav ul {
    display: block;
    margin: 0;
    padding: 0;
}
#nav {
    float: right;
    margin-right: 10px;
}
#nav ul li {
    display: block;
    float: left;
    list-style: none;
    margin: 0;
    padding: 0;
}
#nav ul li a {
    color: white;
    text-decoration: none;
    font-weight: 500;
    display: block;
    text-transform: uppercase;
    font-size: 13.5px;
    line-height: 71px;
    margin: 0;
    padding: 0 12px;
    -moz-transition-property: background-color;
    -o-transition-property: background-color;
    -webkit-transition-property: background-color;
    transition-property: background-color;
    -moz-transition-duration: 0.2s;
    -o-transition-duration: 0.2s;
    -webkit-transition-duration: 0.2s;
    transition-duration: 0.2s;
}
#nav ul li a:hover {
    background: #6db33f;
}
#nav ul li a.active {
    background: #6db33f;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Reactor 3 参考指南</h1>
<div class="details">
<span id="author" class="author">Stephane Maldini</span><br>
<span id="email" class="email"><a href="https://twitter.com/smaldini">@smaldini</a></span><br>
<span id="author2" class="author">Simon Baslé</span><br>
<span id="email2" class="email"><a href="https://twitter.com/simonbasle">@simonbasle</a></span><br>
<span id="revnumber">version 3.3.5.RELEASE</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-doc">1. 关于文档</a>
<ul class="sectlevel2">
<li><a href="#latest_version_copyright_notice">1.1. 最新版本 &amp; 版权声明</a></li>
<li><a href="#contributing_to_the_documentation">1.2. 贡献本文档</a></li>
<li><a href="#getting_help">1.3. 获取帮助</a></li>
<li><a href="#where_to_go_from_here">1.4. 如何开始</a></li>
</ul>
</li>
<li><a href="#getting-started">2. 入门</a>
<ul class="sectlevel2">
<li><a href="#getting-started-introducing-reactor">2.1. 介绍Reactor</a></li>
<li><a href="#prerequisites">2.2. 前提</a></li>
<li><a href="#getting-started-understanding-bom">2.3. 理解 BOM</a></li>
<li><a href="#getting">2.4. 入门Reactor</a></li>
</ul>
</li>
<li><a href="#intro-reactive">3. 响应式编程介绍</a>
<ul class="sectlevel2">
<li><a href="#_阻塞更浪费资源">3.1. 阻塞更浪费资源</a></li>
<li><a href="#_异步能拯救">3.2. 异步能拯救？</a></li>
<li><a href="#_从命令式到响应式编程">3.3. 从命令式到响应式编程</a></li>
</ul>
</li>
<li><a href="#core-features">4. Reactor核心特性</a>
<ul class="sectlevel2">
<li><a href="#flux">4.1. <code>Flux</code>，一个包含0-N个元素的异步序列</a></li>
<li><a href="#mono">4.2. <code>Mono</code>，一个包含0-1结果的异步序列</a></li>
<li><a href="#_简单创建和订阅flux或mono">4.3. 简单创建和订阅Flux或Mono</a></li>
<li><a href="#producing">4.4. 以编程方式创建序列</a></li>
<li><a href="#schedulers">4.5. 线程和调度器</a></li>
<li><a href="#error.handling">4.6. 错误处理</a></li>
<li><a href="#processors">4.7. 处理器</a></li>
</ul>
</li>
<li><a href="#kotlin">5. Kotlin的支持</a>
<ul class="sectlevel2">
<li><a href="#kotlin-requirements">5.1. 要求</a></li>
<li><a href="#kotlin-extensions">5.2. 扩展</a></li>
<li><a href="#kotlin-null-safety">5.3. 空安全</a></li>
</ul>
</li>
<li><a href="#testing">6. 测试</a>
<ul class="sectlevel2">
<li><a href="#_使用_stepverifier_测试一个场景">6.1. 使用 <code>StepVerifier</code> 测试一个场景</a></li>
<li><a href="#_操纵时间">6.2. 操纵时间</a></li>
<li><a href="#_用_stepverifier_执行执行后断言">6.3. 用 <code>StepVerifier</code> 执行执行后断言</a></li>
<li><a href="#_测试_上下文">6.4. 测试 <code>上下文</code></a></li>
<li><a href="#_用_testpublisher_手动发射">6.5. 用 <code>TestPublisher</code> 手动发射</a></li>
<li><a href="#_用_publisherprobe_检查执行路径">6.6. 用 <code>PublisherProbe</code> 检查执行路径</a></li>
</ul>
</li>
<li><a href="#debugging">7. 调试Reactor</a>
<ul class="sectlevel2">
<li><a href="#_典型的响应式堆栈追踪">7.1. 典型的响应式堆栈追踪</a></li>
<li><a href="#debug-activate">7.2. 激活调试模式 - 又名回溯</a></li>
<li><a href="#_在调试模式下读取堆栈跟踪">7.3. 在调试模式下读取堆栈跟踪</a></li>
<li><a href="#reactor-tools-debug">7.4. 可生产的全局调试</a></li>
<li><a href="#_记录序列">7.5. 记录序列</a></li>
</ul>
</li>
<li><a href="#metrics">8. 暴露Reactor的指标</a>
<ul class="sectlevel2">
<li><a href="#_调度器指标">8.1. 调度器指标</a></li>
<li><a href="#_生产者指标">8.2. 生产者指标</a></li>
</ul>
</li>
<li><a href="#advanced">9. 高级特性和概念</a>
<ul class="sectlevel2">
<li><a href="#advanced-mutualizing-operator-usage">9.1. 互用操作符用法</a></li>
<li><a href="#reactor.hotCold">9.2. 热与冷</a></li>
<li><a href="#advanced-broadcast-multiple-subscribers-connectableflux">9.3. 使用 <code>ConnectableFlux</code> 向多个订阅者广播</a></li>
<li><a href="#advanced-three-sorts-batching">9.4. 三种批处理</a></li>
<li><a href="#advanced-parallelizing-parralelflux">9.5. 用 <code>ParallelFlux</code> 并行化工作</a></li>
<li><a href="#scheduler-factory">9.6. 替换默认的 <code>Schedulers</code></a></li>
<li><a href="#hooks">9.7. 使用全局钩子</a></li>
<li><a href="#context">9.8. 为响应式序列添加上下文</a></li>
<li><a href="#cleanup">9.9. 处理需要清理的对象</a></li>
<li><a href="#null-safety">9.10. 空安全</a></li>
</ul>
</li>
<li><a href="#which-operator">Appendix A: 我需要哪个操作符？</a>
<ul class="sectlevel2">
<li><a href="#which.create">A.1. 创建一个新的序列&#8230;&#8203;</a></li>
<li><a href="#which.values">A.2. 转换已有的序列</a></li>
<li><a href="#which.peeking">A.3. 探测序列</a></li>
<li><a href="#which.filtering">A.4. 过滤序列</a></li>
<li><a href="#which.errors">A.5. 处理错误</a></li>
<li><a href="#which.time">A.6. 与时间的合作</a></li>
<li><a href="#which.window">A.7. 拆分 <code>Flux</code></a></li>
<li><a href="#which.blocking">A.8. 回到同步的世界</a></li>
<li><a href="#which.multicasting">A.9. 广播 <code>Flux</code> 到多个 <code>Subscribers</code></a></li>
</ul>
</li>
<li><a href="#faq">Appendix B: 常见问题和最佳实践，“我如何&#8230;&#8203;?”</a>
<ul class="sectlevel2">
<li><a href="#faq.wrap-blocking">B.1. 如何包装一个同步阻塞调用？</a></li>
<li><a href="#faq.chain">B.2. 我在我的 <code>Flux</code> 上使用了一个操作符，但似乎不适用。为什么会这样？</a></li>
<li><a href="#faq.monoThen">B.3. 我的 <code>Mono</code> <code>zipWith</code>/<code>zipWhen</code> 从未被调用过</a></li>
<li><a href="#faq.retryWhen">B.4. 如何使用 <code>retryWhen</code> 来模拟 <code>retry(3)</code>?</a></li>
<li><a href="#faq.exponentialBackoff">B.5. 我如何使用 <code>retryWhen</code> 进行指数退避？</a></li>
<li><a href="#faq.thread-affinity-publishon">B.6. 使用 <code>publishOn()</code> 时如何确保线程关联性？</a></li>
<li><a href="#faq.mdc">B.7. 上下文日志记录的好的方式是什么？（MDC）</a></li>
</ul>
</li>
<li><a href="#reactor-extra">Appendix C: Reactor-Extra</a>
<ul class="sectlevel2">
<li><a href="#extra-tuples">C.1. <code>TupleUtils</code> 和函数式接口</a></li>
<li><a href="#extra-math">C.2. <code>MathFlux</code> 数学操作符</a></li>
<li><a href="#extra-repeat-retry">C.3. 重复和重试工具</a></li>
<li><a href="#extra-schedulers">C.4. 调度器</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-doc"><a class="anchor" href="#about-doc"></a>1. 关于文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章节简要概述了Reactor参考文档，你不必依次阅读该文档，每个章节都是独立的，尽管它们常链接其它的章节。</p>
</div>
<div class="sect2">
<h3 id="latest_version_copyright_notice"><a class="anchor" href="#latest_version_copyright_notice"></a>1.1. 最新版本 &amp; 版权声明</h3>
<div class="paragraph">
<p>Reactor参考文档也提供了HTML版本的，最新可用的副本在 <a href="https://projectreactor.io/docs/core/release/reference/index.html" class="bare">https://projectreactor.io/docs/core/release/reference/index.html</a></p>
</div>
<div class="paragraph">
<p>无论是电子版还是纸质版的文档，只要你这些副本文档包含了版权声明，且不进行任何的收费，你都可以供自己使用或者分享给他人。</p>
</div>
</div>
<div class="sect2">
<h3 id="contributing_to_the_documentation"><a class="anchor" href="#contributing_to_the_documentation"></a>1.2. 贡献本文档</h3>
<div class="paragraph">
<p>本参考文档是用 <a href="https://asciidoctor.org/docs/asciidoc-writers-guide/">Asciidoc</a> 写的，其源码位于 <a href="https://github.com/reactor/reactor-core/tree/master/docs/asciidoc" class="bare">https://github.com/reactor/reactor-core/tree/master/docs/asciidoc</a> 。</p>
</div>
<div class="paragraph">
<p>如果你有任何改进或建议，欢迎提交PR。</p>
</div>
<div class="paragraph">
<p>我们建议你check out源码到本地，便于你运行gradle <code>asciidoctor</code> 任务进行文档的构建以及检查渲染效果。有些部分章节依赖于其包含的文件，因此GitHub的渲染并不总是完整的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
为了便于文档编辑，大部分章节在末尾都有一个链接，可以打开一个直接编辑该章节源文件的GitHub界面。这些链接仅在HTML5版本的文档中提供，如下所示：
<a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" target="_blank" rel="noopener">Suggest Edit</a> to <a href="#about-doc">关于文档</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting_help"><a class="anchor" href="#getting_help"></a>1.3. 获取帮助</h3>
<div class="paragraph">
<p>使用Reactor，你可以通过以下几种方式寻求帮助：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <a href="https://gitter.im/reactor/reactor">Gitter</a> 上与社区取得联系。</p>
</li>
<li>
<p>在stackoverflow.com <a href="https://stackoverflow.com/tags/project-reactor"><code>project-reactor</code></a> 提问。</p>
</li>
<li>
<p>在Github issues上提交bug，我们密切关注这些仓库： <a href="https://github.com/reactor/reactor-core/issues">reactor-core</a> （包括核心功能）和 <a href="https://github.com/reactor/reactor-addons/issues">reactor-addons</a>
（涵盖响应式测试和适配器等问题）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
所有的Reactor项目都是开源的， <a href="https://github.com/reactor/reactor-core/tree/master/docs/asciidoc">包括此文档</a> ，如果你发现此文档存在问题且想改进它，请 <a href="https://github.com/reactor/.github/blob/master/CONTRIBUTING.md">参考</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="where_to_go_from_here"><a class="anchor" href="#where_to_go_from_here"></a>1.4. 如何开始</h3>
<div class="ulist">
<ul>
<li>
<p>如果你想直接进入编程，前往 <a href="#getting-started">入门</a>。</p>
</li>
<li>
<p>如果你刚接触响应式编程，你可能应该从 <a href="#intro-reactive">响应式编程介绍</a> 开始。</p>
</li>
<li>
<p>如果你比较熟悉Reactor的概念，只是在寻找合适的操作，却想不到相关的操作符，请看附录 <a href="#which-operator">我需要哪个操作符？</a>。</p>
</li>
<li>
<p>为了更深入地了解Reactor的核心功能，转至 <a href="#core-features">Reactor核心特性</a> 进行了解：</p>
<div class="ulist">
<ul>
<li>
<p>更多关于Reactor的响应式类型在 <a href="#flux"><code>Flux</code>，一个包含0-N个元素的异步序列</a> 和 <a href="#mono"><code>Mono</code>，一个包含0-1结果的异步序列</a> 章节。</p>
</li>
<li>
<p>怎么使用 <a href="#schedulers">scheduler</a> 进行线程上下文切换。</p>
</li>
<li>
<p>怎么处理错误在 <a href="#error.handling">错误处理</a> 章节。</p>
</li>
</ul>
</div>
</li>
<li>
<p>使用单元测试？在 <code>reactor-test</code> 项目是可以做到的！请看 <a href="#testing">测试</a>。</p>
</li>
<li>
<p><a href="#producing">以编程方式创建序列</a> 章节提供了更多高级的创建响应式源的方式。</p>
</li>
<li>
<p><a href="#advanced">高级特性和概念</a> 章节涵盖了其它高级主题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#about-doc">关于文档</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>2. 入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章节包含的信息有助于你使用Reactor，包含以下部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-introducing-reactor">介绍Reactor</a></p>
</li>
<li>
<p><a href="#prerequisites">前提</a></p>
</li>
<li>
<p><a href="#getting-started-understanding-bom">理解 BOM</a></p>
</li>
<li>
<p><a href="#getting">入门Reactor</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="getting-started-introducing-reactor"><a class="anchor" href="#getting-started-introducing-reactor"></a>2.1. 介绍Reactor</h3>
<div class="paragraph">
<p>Reactor是一个完全非阻塞的JVM响应式编程基础，有着高效的需求管理（背压的形式）。它直接整合Java8的函数式API，尤其是 <code>CompletableFuture</code>， <code>Stream</code>，还有 <code>Duration</code> 。提供了可组合的异步化序列API&#8201;&#8212;&#8201;<code>Flux</code> (对于 [N] 个元素) and <code>Mono</code> (对于 [0|1] 元素)&#8201;&#8212;&#8201;并广泛实现
<a href="https://www.reactive-streams.org/">响应式Stream</a> 规范。</p>
</div>
<div class="paragraph">
<p>Reactor还有支持非阻塞进程间通信的 <code>reactor-netty</code> 项目，适用于微服务架构，Reactor Netty为HTTP （包括Websockets），TCP和UDP提供了背压机制的网络引擎。完全支持响应式编解码。</p>
</div>
</div>
<div class="sect2">
<h3 id="prerequisites"><a class="anchor" href="#prerequisites"></a>2.2. 前提</h3>
<div class="paragraph">
<p>Reactor Core运行在 <code>Java 8</code> 及之上。</p>
</div>
<div class="paragraph">
<p>对于 <code>org.reactivestreams:reactive-streams:1.0.3</code> 传递依赖。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Android的支持</div>
<div class="ulist">
<ul>
<li>
<p>Reactor3并不针对或正式支持Android（如果有很强的需求，考虑使用RxJava2）。</p>
</li>
<li>
<p>然而它在Android SDK 26（Android 0）及之上应该可以正常工作。</p>
</li>
<li>
<p>我们会尽最大的努力去评估有利于支持Android的变化。然而，我们不能确保这一点，必须根据具体的情况作出每个决定。</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-understanding-bom"><a class="anchor" href="#getting-started-understanding-bom"></a>2.3. 理解 BOM</h3>
<div class="paragraph">
<p>Reactor 3使用BOM（依赖清单）模型（从 <code>reactor-core 3.0.4</code> 开始，以及 <code>Aluminium</code> 版本链）。
尽管这些组件之间可能存在版本分歧，但这份精选的组件列表，提供相关的版本，使其在一起能够运行良好。</p>
</div>
<div class="paragraph">
<p>BOM本身是版本化的，它使用了一个代号和限定符的版本链方案。下面的列表展示了一些样例：</p>
</div>
<div class="verseblock">
<pre class="content">Aluminium-RELEASE
Californium-BUILD-SNAPSHOT
Aluminium-SR1
Bismuth-RELEASE
Californium-SR32</pre>
</div>
<div class="paragraph">
<p>版本代号表示为传统上的MAJOR.MINOR数字，它们（大部分）来于 <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">元素周期表</a> ，按照字母顺序递增。</p>
</div>
<div class="paragraph">
<p>限定符（按照时间为顺序）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BUILD-SNAPSHOT</code>：为开发和测试而构建的。</p>
</li>
<li>
<p><code>M1</code>..<code>N</code>：里程碑或者开发人员预览的。</p>
</li>
<li>
<p><code>RELEASE</code>：代号系列中第一个GA（可用的）版本。</p>
</li>
<li>
<p><code>SR1</code>..<code>N</code>：代号系列中随后的GA版本&#8201;&#8212;&#8201;等同于修复数字。（SR表示“<code>服务版本</code>”）</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="getting"><a class="anchor" href="#getting"></a>2.4. 入门Reactor</h3>
<div class="paragraph">
<p>正如 <a href="#前面提到的入门理解BOM">[前面提到的入门理解BOM]</a>，使用BOM和添加相关的依赖在你的工程中是最简单使用Reactor的方式。请注意，当你添加一个依赖时，你必须忽略版本，以便于从BOM中提取版本。</p>
</div>
<div class="paragraph">
<p>但是，如果你想强制的使用一个特定版本的组件，你可以像平时一样在添加依赖时指定其版本。你也可以完全放弃BOM，通过组件的版本指定其依赖。</p>
</div>
<div class="sect3">
<h4 id="_maven上的使用"><a class="anchor" href="#_maven上的使用"></a>2.4.1. Maven上的使用</h4>
<div class="paragraph">
<p>Maven天然支持BOM的概念。首先你需要通过添加下面的片段到你的 <code>pom.xml</code> 来导入BOM。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencyManagement&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;Bismuth-RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注意这 <code>dependencyManagement</code> 标签，这是除了常规 <code>dependencies</code> 的部分。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果这顶层的选项（<code>dependencyManagement</code>）在你的pom中已经存在，仅需要添加内容。</p>
</div>
<div class="paragraph">
<p>接下来，除了没有 <code>&lt;version&gt;</code> 以外，像往常一样，添加你的依赖到相关的reactor工程中，如下所示。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>依赖核心库。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>没有版本标签。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>reactor-test</code> 用作对reactive streams进行单元测试。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gradle上的使用"><a class="anchor" href="#_gradle上的使用"></a>2.4.2. Gradle上的使用</h4>
<div class="paragraph">
<p>在Gradle5.0版本以前，没有对Maven BOM的核心支持，但是你可以使用Spring的 <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">gradle依赖管理</a> 插件。</p>
</div>
<div class="paragraph">
<p>首先，从Gradle插件入口应用该插件，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    id "io.spring.dependency-management" version "1.0.7.RELEASE" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在写本文档时，1.0.7.RELEASE是该插件最新的版本。请检查然后更新它。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>然后使用它导入BOM，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencyManagement {
     imports {
          mavenBom "io.projectreactor:reactor-bom:Bismuth-RELEASE"
     }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后，不添加版本号将依赖添加到你的工程，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>没有第三个 <code>:</code> 为版本分隔的部分，它取值于BOM。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>从Gradle 5.0开始，你可以用原生的Gradle来支持BOM。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
     implementation platform('io.projectreactor:reactor-bom:Bismuth-RELEASE')
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>没有第三个 <code>:</code> 为版本分隔的部分，它取值于BOM。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_里程碑和快照"><a class="anchor" href="#_里程碑和快照"></a>2.4.3. 里程碑和快照</h4>
<div class="paragraph">
<p>里程碑和开发者预览的版本是通过Spring里程碑仓库而不是中央仓库进行发布。请使用如下片段，要将其添加到你的构建配置文件中：</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Java中的里程碑</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-milestones&lt;/id&gt;
		&lt;name&gt;Spring Milestones Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于Gradle，请使用下面的片段：</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Gradle中的里程碑</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样的，快照版本也是在一个单独的专用仓库中可用，如下面的例子所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Maven中的快照版本</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;repositories&gt;
	&lt;repository&gt;
		&lt;id&gt;spring-snapshots&lt;/id&gt;
		&lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
		&lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
	&lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 4. Gradle中的快照版本</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/gettingStarted.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#getting-started">入门</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="intro-reactive"><a class="anchor" href="#intro-reactive"></a>3. 响应式编程介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor是响应式编程范式的一种实现，概括如下：</p>
</div>
<div class="quoteblock">
<blockquote>
响应式编程是一种涉及数据流和变化传播的异步编程范式。这意味着可以通过编程语言轻松地表示静态（如数组）或动态（如事件发射器）数据流。
</blockquote>
<div class="attribution">
&#8212; https://en.wikipedia.org/wiki/Reactive_programming
</div>
</div>
<div class="paragraph">
<p>作为响应式编程方向上的第一步，Microsoft在.NET生态中创建了响应式(Rx)扩展库。然后RxJava实现了JVM上的响应式编程。随着时间的推移，通过Reactive Streams的努力，一套基于JVM为响应式库定义接口与交互规则的标准规范`Reactive Streams` 出现了。其接口已经集成到了Java9中的 <code>Flow</code> 类下。</p>
</div>
<div class="paragraph">
<p>响应式编程经常作为观察者设计模式的一种扩展在面向对象编程语言中体现。你还可以将响应式流模式和熟悉的迭代器设计模式进行比较，它们的核心库都基于 <code>Iterable</code>-<code>Iterator</code> 组合。一个主要的区别是，迭代器基于拉的，而响应式流是基于推的。</p>
</div>
<div class="paragraph">
<p>迭代器是一种命令式编程模式，即使获取值完全取决于 <code>Iterable</code>。事实上，这取决于开发者在序列中选择何时调用 <code>next()</code>。在响应式流中，上面的组合等价于 <code>Publisher-Subscriber</code> 。但当有新的可用的数据到来时，<code>Publisher</code> 会对订阅者进行通知，这种推动是响应式的关键。当然，使用推送值的操作应表现为声明式的而不是命令式的：开发者应专注于表达逻辑计算而不是描述确切的流控制。</p>
</div>
<div class="paragraph">
<p>除了推送数据外，还以明确的覆盖了错误处理和完成方面。<code>Publisher</code> 可以推送新的数据到其 <code>Subscriber</code>（通过调用 <code>onNext</code> ），也可以发送错误（通过调用 <code>onError</code>）或者完成（通过调用 <code>onComplete</code>）信号。错误和完成信号都会终止序列。可以总结如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>onNext x 0..N [onError | onComplete]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方式非常灵活，适用于零个值，一个值或者N个值（包括无限序列，例如持续的时钟滴答声）。</p>
</div>
<div class="paragraph">
<p>但是首先需要思考的是，我们为什么需要这样的异步响应式库呢？</p>
</div>
<div class="sect2">
<h3 id="_阻塞更浪费资源"><a class="anchor" href="#_阻塞更浪费资源"></a>3.1. 阻塞更浪费资源</h3>
<div class="paragraph">
<p>现代应用程序有着巨大的并发用户，即使当代的硬件性能已经提升了不少，但是软件的性能依然是一个关键因素。</p>
</div>
<div class="paragraph">
<p>通常有两种方式来提升应用的性能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用更多的线程和硬件资源达到 <strong>并行化</strong></p>
</li>
<li>
<p>在当前使用的资源上 <strong>寻求更高效的处理</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，Java开发者使用同步方式编程，这种做法在遇到性能瓶颈之前是可行的。当然此时可能会引入更多的线程来运行相同的同步代码。但是像这种资源利用率的扩展，很快会引入竞争和并发的问题。</p>
</div>
<div class="paragraph">
<p>更糟糕的是，阻塞浪费资源。如果你仔细观察，一旦程序涉及一些延时操作（特别是I/O，例如数据库请求或者网络调用），由于线程（可能有很多线程）等待数据而处于空闲，导致资源的浪费。</p>
</div>
<div class="paragraph">
<p>因此，并行化并不是银弹。虽然为了充分利用硬件资源是有必要的，但是也带来了复杂性和容易造成资源浪费。</p>
</div>
</div>
<div class="sect2">
<h3 id="_异步能拯救"><a class="anchor" href="#_异步能拯救"></a>3.2. 异步能拯救？</h3>
<div class="paragraph">
<p>先前提到的第二种方式，寻求更高的效率，可以解决资源浪费问题。通过编写异步非阻塞的代码，你可以将执行切换到使用了相同底层资源的另一个活动任务，然后在异步处理完成后返回到当前任务。</p>
</div>
<div class="paragraph">
<p>但是你如何在JVM上编写异步代码？Java提供了两种异步编程模型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Callbacks</strong>：异步方法没有一个返回值，但是它额外的传递了一个 <code>callback</code> 参数（lambda或者匿名类），在当结果可返回时调用。熟知的例子就是Swing的 <code>EventListener</code> 体系。</p>
</li>
<li>
<p><strong>Futures</strong>：异步方法 <em>立即</em> 返回一个 <code>Future&lt;T&gt;</code>。异步处理计算得到这个 <code>T</code> 值，<code>Future</code> 对象对获取该值进行了包装，这个对象可以一直轮询直到返回该值。例如，<code>ExecutorService</code> 使用 <code>Future</code> 对象执行 <code>Callable&lt;T&gt;</code> 任务。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些技术够好？并不适用于每个用例，两种方式都有局限性。</p>
</div>
<div class="paragraph">
<p>回调难以组合在一起，很容易导致代码难以阅读和维护（著名的地狱回调）。</p>
</div>
<div class="paragraph">
<p>举个例子：在界面上展示一个用户的最优先的五个喜好，如果都没有，则在界面上进行建议。通过调用三个服务（第一个提供喜好ID，第二个获取喜好详情，第三个提供详情建议），如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. 地狱回调示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">userService.getFavorites(userId, new Callback&lt;List&lt;String&gt;&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>
  public void onSuccess(List&lt;String&gt; list) { <i class="conum" data-value="2"></i><b>(2)</b>
    if (list.isEmpty()) { <i class="conum" data-value="3"></i><b>(3)</b>
      suggestionService.getSuggestions(new Callback&lt;List&lt;Favorite&gt;&gt;() {
        public void onSuccess(List&lt;Favorite&gt; list) { <i class="conum" data-value="4"></i><b>(4)</b>
          UiUtils.submitOnUiThread(() -&gt; { <i class="conum" data-value="5"></i><b>(5)</b>
            list.stream()
                .limit(5)
                .forEach(uiList::show); <i class="conum" data-value="6"></i><b>(6)</b>
            });
        }

        public void onError(Throwable error) { <i class="conum" data-value="7"></i><b>(7)</b>
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() <i class="conum" data-value="8"></i><b>(8)</b>
          .limit(5)
          .forEach(favId -&gt; favoriteService.getDetails(favId, <i class="conum" data-value="9"></i><b>(9)</b>
            new Callback&lt;Favorite&gt;() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们提供了基于回调的服务：一个`Callback` 接口包含当异步处理成功和失败时的两个方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个服务使用喜好列表ID执行回调。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果列表为空，则必须转到 <code>suggestionService</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>suggestionService</code> 将 <code>List&lt;Favorite&gt;</code> 给到第二个回调。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>由于我们处理的是UI，我们需要确保我们的消费代码跑在UI线程。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>我们使用Java8 <code>Stream</code> 来限制建议的数量为5个，并且将它们展示在UI的图形列表中。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在每个级别，我们都以相同的方式处理错误：将其显示在弹出窗口中。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>返回到喜好ID级别。如果服务返回了完整的列表，我们需要转到 <code>favoriteService</code> 来获取详细的 <code>Favorite</code> 对象。因为我们只需要五个，所以我们首先将ID列表的流限制为5个。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>再一次回调。这一次我们得到一个完整的 <code>Favorite</code> 对象，我们在UI线程内将其推送到UI。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>存在大量包含重复且难以追踪的代码。在Reactor实现相同的功能：</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. 与回调代码等价的Reactor代码示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">userService.getFavorites(userId) <i class="conum" data-value="1"></i><b>(1)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="2"></i><b>(2)</b>
           .switchIfEmpty(suggestionService.getSuggestions()) <i class="conum" data-value="3"></i><b>(3)</b>
           .take(5) <i class="conum" data-value="4"></i><b>(4)</b>
           .publishOn(UiUtils.uiThreadScheduler()) <i class="conum" data-value="5"></i><b>(5)</b>
           .subscribe(uiList::show, UiUtils::errorPopup); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们从一个喜好ID的流开始。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们 <em>异步地将它们转换</em> 为详细的 <code>Favorite</code> 对象(<code>flatMap</code>)。现在我们有了一个 <code>Favorite</code> 的流。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果 <code>Favorite</code> 流为空，我们降级到 <code>suggestionService</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们最多只关注结果流中的五个元素。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最后我们处理UI线程中的每个元素。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>我们通过描述最终如何处理数据的形式来触发流（在UI列表中显示）以及出现错误时的操作（显示弹出窗口）。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果想要确保在800ms内检索到喜好ID，当耗时较长时，从缓存中获取？在基于回调的代码中，这是一个复杂的任务。在Reactor中，在链中添加一个 <code>timeout</code> 操作符就变得非常简单，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. 超时和回退的Reactor代码示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) <i class="conum" data-value="1"></i><b>(1)</b>
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) <i class="conum" data-value="2"></i><b>(2)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="3"></i><b>(3)</b>
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果以上部分在800ms内没有发射出元素，则传播一个错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果发生错误，降级到 <code>cacheService</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>链的其余部分与前面的示例类似。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Future</code> 对象比回调稍微好一点，但依然难以进行组合，尽管Java8中 <code>CompletableFuture</code> 对其做了改进。编排多个 <code>Future</code> 对象在一起虽然是可以行的，但并不容易。另外，<code>Future</code> 有其它的问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>调用 <code>get()</code> 方法很容易导致 <code>Future</code> 对象出现另一个阻塞的情况。</p>
</li>
<li>
<p>不支持惰性计算。</p>
</li>
<li>
<p>缺乏对多值和高级错误处理的支持。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑另外一个示例：获取到一个ID列表，我们需要获取其名称或统计信息并将其组合，且所有的操作都是异步的。下面的例子使用 <code>CompletableFuture</code> 类型列表执行此操作：</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. <code>CompletableFuture</code> 组合示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <i class="conum" data-value="1"></i><b>(1)</b>

CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
	Stream&lt;CompletableFuture&lt;String&gt;&gt; zip =
			l.stream().map(i -&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
				CompletableFuture&lt;String&gt; nameTask = ifhName(i); <i class="conum" data-value="4"></i><b>(4)</b>
				CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); <i class="conum" data-value="5"></i><b>(5)</b>

				return nameTask.thenCombineAsync(statTask, (name, stat) -&gt; "Name " + name + " has stats " + stat); <i class="conum" data-value="6"></i><b>(6)</b>
			});
	List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); <i class="conum" data-value="7"></i><b>(7)</b>
	CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

	CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <i class="conum" data-value="8"></i><b>(8)</b>
	return allDone.thenApply(v -&gt; combinationList.stream()
			.map(CompletableFuture::join) <i class="conum" data-value="9"></i><b>(9)</b>
			.collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); <i class="conum" data-value="10"></i><b>(10)</b>
assertThat(results).contains(
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121");</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从一个给定需要处理的 <code>id</code> 列表开始。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一旦得到列表，我们需要进一步的异步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>遍历列表中的每个元素。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>异步获取关联的名称。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>异步获取关联的任务。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>合并结果。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>现在，我们有了表示所有组合任务的future列表。为了执行这些任务，我们需要转换列表为数组。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>将数组传递给 <code>CompletableFuture.allOf</code>，输出到一个 <code>Future</code> 对象，然后当所有的任务都完成后完成。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>棘手的是，<code>allOf</code> 返回 <code>CompletableFuture&lt;Void&gt;</code> ，我们重新遍历future列表，使用 <code>join()</code> 收集其结果（这里不会阻塞，因为 <code>allOf</code> 已经确保这些futures已经完成）。</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>一旦触发了整个异步链，我们就可以等待其执行结果返回，且断言返回的结果。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>由于Reactor提供了更多开箱即用的组合运算符，这个过程可以被简化如下：</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. 与future代码等价的Reactor代码示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; ids = ifhrIds(); <i class="conum" data-value="1"></i><b>(1)</b>

Flux&lt;String&gt; combinations =
		ids.flatMap(id -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
			Mono&lt;String&gt; nameTask = ifhrName(id); <i class="conum" data-value="3"></i><b>(3)</b>
			Mono&lt;Integer&gt; statTask = ifhrStat(id); <i class="conum" data-value="4"></i><b>(4)</b>

			return nameTask.zipWith(statTask, <i class="conum" data-value="5"></i><b>(5)</b>
					(name, stat) -&gt; "Name " + name + " has stats " + stat);
		});

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <i class="conum" data-value="6"></i><b>(6)</b>

List&lt;String&gt; results = result.block(); <i class="conum" data-value="7"></i><b>(7)</b>
assertThat(results).containsExactly( <i class="conum" data-value="8"></i><b>(8)</b>
		"Name NameJoe has stats 103",
		"Name NameBart has stats 104",
		"Name NameHenry has stats 105",
		"Name NameNicole has stats 106",
		"Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这一次，我们从已提供的一个异步序列 <code>ids</code>（<code>Flux&lt;String&gt;</code>）开始。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对于序列中的每个元素，我们异步处理（在调用的 <code>flatMap</code> 函数内部）两次。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取关联的名称。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>获取关联的统计信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>异步合并两个结果值。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>在值可用时聚合到 <code>List</code> 中。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在生产中，我们会进一步通过 <code>Flux</code> 异步的组合或者订阅。一般情况下，我们会返回 <code>result</code> <code>Mono</code>。由于我们现在用作测试，我们阻塞等待结果处理完成，然后直接返回聚合的值列表。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>断言结果。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>使用回调和 <code>Future</code> 对象的缺点是相似的，且是 <code>Publisher-Subscriber</code> 的响应式编程所要解决的问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从命令式到响应式编程"><a class="anchor" href="#_从命令式到响应式编程"></a>3.3. 从命令式到响应式编程</h3>
<div class="paragraph">
<p>诸如Reactor之类的响应式库，旨在解决JVM上这些 " <code>经典</code> "的异步方法的缺点，同时还关注一些其它的方面：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>组合性</strong> 和 <strong>易读性</strong></p>
</li>
<li>
<p>数据作为 <strong>流</strong> 操作，且有着丰富的 <strong>操作符</strong></p>
</li>
<li>
<p>在 <strong>订阅</strong> 之前什么都不会发生</p>
</li>
<li>
<p><strong>背压</strong> 或 <em>消费者向生产者发送信号表示发布速率太快</em></p>
</li>
<li>
<p>与 <em>并发无关</em> 的高阶抽象</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_组合性和易读性"><a class="anchor" href="#_组合性和易读性"></a>3.3.1. 组合性和易读性</h4>
<div class="paragraph">
<p>"可组合性"是指能够编排多个异步任务，我们使用先前任务的结果将输入提供给后续任务。另外，我们可以以fork-join的形式运行多个任务。此外，我们能复用异步任务作为离散组件到更高层次的系统中。</p>
</div>
<div class="paragraph">
<p>编排任务的能力是与代码的可读性和可维护性紧密耦合。随着异步处理的层数和复杂性的增加，编写和阅读代码变得越来越困难。正如我们看到的一样，整个回调模型是非常简单的，但是其主要的缺点之一是，对于复杂的处理，你需要从一个回调中执行一个回调，其本身嵌套在另一个回调中，依此类推。这种混乱被称为"地狱回调"。正如你所料到的（或从经验得知），如此的代码是相当难以回溯和推理的。</p>
</div>
<div class="paragraph">
<p>Reactor提供了丰富的组合选项，其中在代码中反映了抽象过程，并且所有内容通常保持在同一级别（减少嵌套）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类比流水线"><a class="anchor" href="#_类比流水线"></a>3.3.2. 类比流水线</h4>
<div class="paragraph">
<p>你可以将响应式应用数据处理当作在组装流水线上流动。Reactor既是流水线又是工作站。原料来源于（原始的 <code>Publisher</code>）并最终作为一个产品，准备推送到消费者（<code>Subscriber</code>）。</p>
</div>
<div class="paragraph">
<p>原料可以通过各种转换和其它的中间步骤，或者将中间零件聚合在一起成为更大的流水线的一部分。如果在某一点出现故障或者堵塞（也许产品装箱所需时间过长），当前被影响到的工作站可以向上游发出信号来限制原料的流动。</p>
</div>
</div>
<div class="sect3">
<h4 id="_操作符"><a class="anchor" href="#_操作符"></a>3.3.3. 操作符</h4>
<div class="paragraph">
<p>在Reactor中，操作符是我们流水线类比中的工作站。每个操作符添加行为到 <code>Publisher</code> 中，并将上一步的 <code>Publisher</code> 包装到新的实例中。因此，整个链被链接在一起，数据源于第一个 <code>Publisher</code> 沿着链向下移动，并通过每个链接进行转换。最终，<code>Subscriber</code> 完成处理。记住，正如我们很快会看到的，在 <code>Subscriber</code> 订阅 <code>Publisher</code> 之前，什么都不会发生。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
理解操作符创建新的实例可以帮助你避免一个常见的错误，该错误会导致你认为你在链中使用的运算符未被应用。请参见FAQ中 <a href="#faq.chain">item</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>尽管在响应式流规范中根本没有指定操作符，Reactor作为优秀响应式库中之一的添加了这些操作，提供了丰富的操作符。且涉及了很多方面，从简单的转换和过滤到复杂的编排和错误处理。</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.subscribe"><a class="anchor" href="#reactive.subscribe"></a>3.3.4. <code>subscribe()</code> 之前什么都不会发生</h4>
<div class="paragraph">
<p>在Reactor中，当你写一个 <code>Publisher</code> 链时，默认情况下不会开始注入数据。相反，你可以创建异步处理（有助于重用和组合）的抽象描述。</p>
</div>
<div class="paragraph">
<p>通过 <strong>订阅</strong>，可以将 <code>Publisher</code> 与 <code>Subscriber</code> 进行绑定，从而触发整个链中的流数据。这是在内部实现的，通过单个 <code>request</code> 信号从 <code>Subscriber</code> 传播到上游，一直传回到 <code>Publisher</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.backpressure"><a class="anchor" href="#reactive.backpressure"></a>3.3.5. 背压</h4>
<div class="paragraph">
<p>向上游传播信号也用作实现 <strong>背压</strong>，我们在组装流水线类比中将其描述为，当工作站的处理速度比上游工作站慢时，沿生产线向上发送反馈信号。</p>
</div>
<div class="paragraph">
<p>响应式流规范所定义的实际机制与类比非常接近：一个订阅者可以以 <em>无界</em> 模式工作，并让源以其最快的速率推送所有的数据，也可以使用 <code>request</code> 机制向源发送信号，表明已准备好最多处理 <code>n</code> 个元素。</p>
</div>
<div class="paragraph">
<p>中间操作符也可以在中途改变请求。设想一个以十为一组将元素进行分组的 <code>buffer</code> 操作符。如果订阅者请求一个buffer，源可以生成十个元素。一些操作符还实现了 <strong>提前获取</strong> 的策略，能够避免 <code>request(1)</code> 往返，如果在请求之前生产元素的成本不太高，那么这种策略是有益的。</p>
</div>
<div class="paragraph">
<p>这会将推模式转换为 <strong>推拉混合</strong>，当元素随时可用时，下游可以从上游获取n个元素。但是如果这些元素还没准备好，每当它们被生产时，就会被上游推送到下游。</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.hotCold"><a class="anchor" href="#reactive.hotCold"></a>3.3.6. 热 vs 冷</h4>
<div class="paragraph">
<p>Rx系列的响应库区分了两大类响应式序列：<strong>热</strong> 和 <strong>冷</strong>，这种区别主要与响应式流如何对订阅者作出反应相关：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个 <strong>冷</strong> 的序列会对每个 <code>Subscriber</code> 都重新开始，包括数据源。例如，如果源包装了一个HTTP调用，则会为每个订阅发起一个新的HTTP请求。</p>
</li>
<li>
<p>一个 <strong>热</strong> 的序列对每个 <code>Subscriber</code> 并非是从头开始。更确切地说，晚到的订阅者会在订阅后接收到发送的信号。但是注意，有些热的响应式流可以缓存或者重置全部或部分下发历史。从一般的角度来看，一个热的序列即使没有订阅者处于监听（对于"`订阅之前什么都不会发生`"规则是个例外），也能下发。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>关于Reactor上下文中热与冷的更多信息，请看 <a href="#reactor.hotCold">reactor专门章节</a>。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/reactiveProgramming.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#intro-reactive">响应式编程介绍</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-features"><a class="anchor" href="#core-features"></a>4. Reactor核心特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor项目的主要组件为 <code>reactor-core</code>，一个专注于响应式流规范并基于Java8的响应式库。</p>
</div>
<div class="paragraph">
<p>Reactor引入了可组合的响应式类型，这些类型既实现了 <code>Publisher</code> 又提供了丰富的操作符：<code>Flux</code> 和 <code>Mono</code>。一个 <code>Flux</code> 对象表示含有0..N个元素的响应式序列。而一个 <code>Mono</code> 对象表示单个值或为空（0..1）的结果。</p>
</div>
<div class="paragraph">
<p>这种区别在类型中包含了一些语义信息，表明异步处理的初略基数。例如，一个HTTP请求仅一个响应，因此执行 <code>count</code> 操作没有太大的意义。因此对于一次HTTP调用的结果表示为 <code>Mono&lt;HttpResponse&gt;</code> 相较于 <code>Flux&lt;HttpResponse&gt;</code> 更有意义，因为它仅提供零项或者一项与上下文相关的的操作符。</p>
</div>
<div class="paragraph">
<p>操作符也能转换到相关类型，来改变要处理的最大基数。例如，<code>count</code> 操作符存在于 <code>Flux</code>，但它返回的是 <code>Mono&lt;Long&gt;</code>。</p>
</div>
<div class="sect2">
<h3 id="flux"><a class="anchor" href="#flux"></a>4.1. <code>Flux</code>，一个包含0-N个元素的异步序列</h3>
<div class="paragraph">
<p>下图显示了 <code>Flux</code> 如何转换元素：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flux.png" alt="Flux">
</div>
</div>
<div class="paragraph">
<p><code>Flux&lt;T&gt;</code> 是一个标准的 <code>Publisher&lt;T&gt;</code>，表示为发出0到N个元素的异步序列，可由完成或者错误信号进行选择性终止。在响应式流规范中，这三种类型信号转换为调用下游订阅者的 <code>onNext</code> ，<code>onComplete</code>，和 <code>onError</code> 方法。</p>
</div>
<div class="paragraph">
<p>在如此之大可能信号的范围的情况下，<code>Flux</code> 是通用的响应式类型。请注意所有的事件，甚至是终止事件都是可选的：没有 <code>onNext</code> 事件但是有 <code>onComplete</code> 事件表示为一个 <em>空</em> 的有限序列，但去掉 <code>onComplete</code> ，会有一个 <em>无限</em> 的空序列（除了关于取消的测试外，并没有什么用）。同样，无限序列并不一定总为空的。例如，<code>Flux.interval(Duration)</code> 产生一个无穷的且周期性的发出的 <code>Flux&lt;Long&gt;</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="mono"><a class="anchor" href="#mono"></a>4.2. <code>Mono</code>，一个包含0-1结果的异步序列</h3>
<div class="paragraph">
<p>下图显示了 <code>Mono</code> 如何转换元素：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mono.png" alt="Mono">
</div>
</div>
<div class="paragraph">
<p><code>Mono&lt;T&gt;</code> 是一个特定的 <code>Publisher&lt;T&gt;</code>，最多可以发出一个元素，可以被 <code>onComplete</code> 或 <code>onError</code> 信号选择性终止。</p>
</div>
<div class="paragraph">
<p>它仅提供可用于 <code>Flux</code> 的子集操作符，且一些操作符（特别是那些将 <code>Mono</code> 和另一个 <code>Publisher</code> 结合起来的操作符）能够切换到 <code>Flux</code>。例如，<code>Mono#concatWith(Publisher)</code> 返回一个 <code>Flux</code>，而 <code>Mono#then(Mono)</code> 返回另一个 <code>Mono</code>。</p>
</div>
<div class="paragraph">
<p>注意，你可以使用 <code>Mono</code> 来表示具有完成（类似于 <code>Runnable</code>）概念的无值异步处理。使用 <code>Mono&lt;Void&gt;</code> 来进行创建。</p>
</div>
</div>
<div class="sect2">
<h3 id="_简单创建和订阅flux或mono"><a class="anchor" href="#_简单创建和订阅flux或mono"></a>4.3. 简单创建和订阅Flux或Mono</h3>
<div class="paragraph">
<p>使用各自类中众多的工厂方法之一是上手 <code>Flux</code> 和 <code>Mono</code> 的最简单的方式。</p>
</div>
<div class="paragraph">
<p>例如，要创建一个 <code>String</code> 序列，可以枚举它们或者将它们放入到一个集合中，并从中创建Flux，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; seq1 = Flux.just("foo", "bar", "foobar");

List&lt;String&gt; iterable = Arrays.asList("foo", "bar", "foobar");
Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>其它工厂方法示例包括如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono&lt;String&gt; noData = Mono.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

Mono&lt;String&gt; data = Mono.just("foo");

Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注意，即使整个工厂方法没有任何值，也需要标注泛型类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个参数是范围的开始，第二个参数是产生元素的个数。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在订阅时，<code>Flux</code> 和 <code>Mono</code> 使用Java8的lambda语法。你可以选择各种各样的 <code>.subscribe()</code> 形式，将lambda使用于不同的回调组合，如下面的方法签名所示：</p>
</div>
<div id="subscribeMethods" class="exampleblock">
<div class="title">Example 10. 基于Lambda的 <code>Flux</code> 的订阅形式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">subscribe(); <i class="conum" data-value="1"></i><b>(1)</b>

subscribe(Consumer&lt;? super T&gt; consumer); <i class="conum" data-value="2"></i><b>(2)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer); <i class="conum" data-value="3"></i><b>(3)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer); <i class="conum" data-value="4"></i><b>(4)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>订阅并触发序列。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对每个产生的值做一些操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>处理值时也会对错误作出反应。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>处理值和错误，且在序列成功完成时运行一些代码。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>处理值和错误以及成功完成，但也要处理 <code>subscribe</code> 调用产生的 <code>Subscription</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
这些不同的形式会返回订阅的引用，当不需要更多的数据时，可以通过该引用来取消订阅。取消后，源应停止生产数据并清除它所创建的任何资源。在Reactor中，使用通用 <code>Disposable</code> 接口来表示取消和清理行为。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_subscribe_方法示例"><a class="anchor" href="#_subscribe_方法示例"></a>4.3.1. <code>subscribe</code> 方法示例</h4>
<div class="paragraph">
<p>本节包含了 <code>subscribe</code> 方法的五个签名的最简单示例。以下代码显示了一个没有参数的基本方法的例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个 <code>Flux</code>，在订阅者连接时生成三个值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>用最简单的方式订阅。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码不会产生任何可见的输出，但它确实起作用。<code>Flux</code> 产生三个值。如果我们提供一个lambda，则可以让这些值可见。<code>subscribe</code> 方法的下一个示例显示了一种使值显示的方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个 <code>Flux</code>，在订阅者连接时生成三个值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>用能打印值的订阅者进行订阅。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>1
2
3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了演示下一个方法签名，我们故意引入一个错误，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4) <i class="conum" data-value="1"></i><b>(1)</b>
      .map(i -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        if (i &lt;= 3) return i; <i class="conum" data-value="3"></i><b>(3)</b>
        throw new RuntimeException("Got to 4"); <i class="conum" data-value="4"></i><b>(4)</b>
      });
ints.subscribe(i -&gt; System.out.println(i), <i class="conum" data-value="5"></i><b>(5)</b>
      error -&gt; System.err.println("Error: " + error));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个 <code>Flux</code>，在订阅者连接时生成四个值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们需要一个map，这样我们就可以对一些值进行不同的处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对于大多数值，返回该值。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>对于一个值，强制发生错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>用包括错误处理的订阅者进行订阅。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>我们现在有两个lambda表达式：一个是我们期望的内容，一个是错误。前面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>1
2
3
Error: java.lang.RuntimeException: Got to 4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>subscribe</code> 方法的下一个签名包括错误处理和完成事件处理，如下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done")); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个 <code>Flux</code>，在订阅者连接时生成四个值。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>用包含完成事件处理的订阅者进行订阅。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>错误信号和完成信号都是终止事件，并且彼此互斥（你永远不会同时得到这两个信号）。为了完成消费，我们必须注意不要触发错误。</p>
</div>
<div class="paragraph">
<p>完成回调没有输入，用一对空括号表示：它与 <code>Runnable</code> 接口中的 <code>run</code> 方法相匹配。上面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>1
2
3
4
Done</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>subscribe</code> 方法的最后一个签名包括一个 <code>Consumer&lt;Subscription&gt;</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这种形式要求你对 <code>Subscription</code>（对其执行 <code>request(long)</code> 或 <code>cancel()</code>）做一些事情。否则 <code>Flux</code> 会挂起。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示了 <code>subscribe</code> 方法的最后一个签名：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done"),
    sub -&gt; sub.request(10)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当我们订阅时，我们会收到一个 <code>Subscription</code>。表示我们最多希望从源（实际上会发出4个元素并完成）中接收到 <code>10</code> 个元素。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_用_disposable_取消_subscribe"><a class="anchor" href="#_用_disposable_取消_subscribe"></a>4.3.2. 用 <code>Disposable</code> 取消 <code>subscribe()</code></h4>
<div class="paragraph">
<p>所有这些基于lambda的 <code>subscribe()</code> 形式都有一个 <code>Disposable</code> 返回类型。在这种情况下，<code>Disposable</code> 接口表示订阅都可以通过调用其 <code>dispose()</code> 方法来 <em>取消</em> 订阅。</p>
</div>
<div class="paragraph">
<p>对于 <code>Flux</code> 或 <code>Mono</code> 来说，取消是源应该停止产生元素的信号。然而，并不能保证立即执行：某些源可能产生元素的速度太快，以至于它们甚至可以在收到取消指令之前就能完成。</p>
</div>
<div class="paragraph">
<p><code>Disposables</code> 类中提供了一些关于 <code>Disposable</code> 的工具集。其中，<code>Disposables.swap()</code> 创建了一个 <code>Disposable</code> 包装器，让你可以原子地取消和替换一个具体的 <code>Disposable</code>。这在UI场景中会非常有用，例如，当用户单击按钮时，你想取消请求并将其替换为新的请求。处理包装本身会关闭它。这样做会处理掉当前的具体值和所有未来尝试的替换。</p>
</div>
<div class="paragraph">
<p>另一个有趣的工具方法是 <code>Disposables.composite(&#8230;&#8203;)</code>。这个组合可以让你收集多个 <code>Disposable</code>&#8201;&#8212;&#8201;例如，与一个服务调用相关联的多个进行中的请求&#8201;&#8212;&#8201;并在稍后一次性处理所有这些请求。一旦组合的 <code>dispose()</code> 方法被调用，任何试图添加另一个 <code>Disposable</code> 的尝试都会立即处理它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_lambda的替代方案basesubscriber"><a class="anchor" href="#_lambda的替代方案basesubscriber"></a>4.3.3. Lambda的替代方案：<code>BaseSubscriber</code></h4>
<div class="paragraph">
<p>另外还有一个更通用的 <code>subscribe</code> 方法，它接受一个完整的 <code>Subscriber</code>，而不是用lambda组成一个。为了帮助编写这样的 <code>Subscriber</code>，我们提供了一个名为 <code>BaseSubscriber</code> 的可扩展类。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>BaseSubscriber</code>（或其子类）的实例是 <strong>单一用途</strong>，这意味着，如果一个 <code>BaseSubscriber</code> 订阅了第二个 <code>Publisher</code>，则会取消对第一个 <code>Publisher</code> 的订阅。这是因为使用一个实例两次违反了响应式流的规则，即 <code>Subscriber</code> 的 <code>onNext</code> 方法必须不能被并行调用。因此，只有在对 <code>Publisher#subscribe(Subscriber)</code> 的调用中直接声明匿名实现时，匿名实现才是不错的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们可以实现其中的一个。我们称之为 <code>SampleSubscriber</code>。下面的例子显示了如何将其附加到 <code>Flux</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SampleSubscriber&lt;Integer&gt; ss = new SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; {System.out.println("Done");},
    s -&gt; s.request(10));
ints.subscribe(ss);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子显示了 <code>SampleSubscriber</code> 作为 <code>BaseSubscriber</code> 的简约实现的样子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.projectreactor.samples;

import org.reactivestreams.Subscription;

import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber&lt;T&gt; extends BaseSubscriber&lt;T&gt; {

	public void hookOnSubscribe(Subscription subscription) {
		System.out.println("Subscribed");
		request(1);
	}

	public void hookOnNext(T value) {
		System.out.println(value);
		request(1);
	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>SampleSubscriber</code> 类扩展了 <code>BaseSubscriber</code>，在Reactor中，它作为用户自定义的 <code>Subscribers</code> 的推荐抽象类。这个类提供了可以被重载并以此来调整订阅者行为的钩子。默认情况下，它会触发一个无界的请求，且行为方式与 <code>subscribe()</code> 完全相同。然而，当你想要一个自定义请求数量时，扩展一个 <code>BaseSubscriber</code> 会更有用。</p>
</div>
<div class="paragraph">
<p>对于一个自定义请求数量，最起码是像我们一样实现 <code>hookOnSubscribe(Subscription subscription)</code> 和 <code>hookOnNext(T value)</code>。在我们的例子中，<code>hookOnSubscribe</code> 方法打印一条语句到标准输出并发出第一个请求。然后 <code>hookOnNext</code> 方法打印一条语句并执行其它的请求，每次一个请求。</p>
</div>
<div class="paragraph">
<p><code>SampleSubscriber</code> 类产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Subscribed
1
2
3
4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>BaseSubscriber</code> 还提供了一个 <code>requestUnbounded()</code> 方法来切换到无界模式（相当于 <code>request(Long.MAX_VALUE)</code>），以及一个 <code>cancel()</code> 方法。</p>
</div>
<div class="paragraph">
<p>它还具有其它钩子：<code>hookOnComplete</code>，<code>hookOnError</code>，<code>hookOnCancel</code>，和 <code>hookFinally</code>（总是在序列终止时被调用，终止类型作为 <code>SingalType</code> 参数传递）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你几乎肯定要实现 <code>hookOnError</code>，<code>hookOnCancel</code>，和 <code>hookOnComplete</code> 方法。你可能还想实现 <code>hookFinally</code> 方法。<code>SampleSubscribe</code> 是 <em>执行有界请求</em> 的 <code>Subscriber</code> 的绝对最小实现。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_关于背压和调整请求的方法"><a class="anchor" href="#_关于背压和调整请求的方法"></a>4.3.4. 关于背压和调整请求的方法</h4>
<div class="paragraph">
<p>在Reactor中实现背压时，通过向上游操作符发送 <code>request</code>，将消费者的压力传回到源端。当前请求的总和有时被称为当前 &#8220;需求&#8221;，或者 &#8220;等待的请求&#8221;。
请求的上限为 <code>Long.MAX_VALUE</code>，表示为无限制的请求（意思是"`尽可能快的生产`"&#8201;&#8212;&#8201;基本上是禁用了背压）。</p>
</div>
<div class="paragraph">
<p>第一个请求来自于订阅时的最终订阅者，然而最直接的订阅方式都会立即触发一个 <code>Long.MAX_VALUE</code> 的无界请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subscribe()</code> 和大多数基于lambda的形式（具有 Consumer&lt;Subscription&gt; 的除外）</p>
</li>
<li>
<p><code>block()</code>，<code>blockFirst()</code> 和 <code>blockLast()</code></p>
</li>
<li>
<p>在 <code>toIterable()</code> 或 <code>toStream()</code> 上迭代</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>自定义原始请求最简单的方法是使用重写了 <code>hookOnSubscribe</code> 方法的 <code>BaseSubscriber</code> 来 <code>subscribe</code>，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println("request of " + r))
    .subscribe(new BaseSubscriber&lt;Integer&gt;() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码片段打印出以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>request of 1
Cancelling after having received 1</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
在处理一个请求时，你必须小心产生足够的需求以使序列前进，否则Flux可能会被 “<code>卡住</code>”。这就是为什么 <code>BaseSubscriber</code> 在 <code>hookOnSubscribe</code> 默认为无限的请求。当重写这个钩子时，你通常应该至少调用一次 <code>request</code>。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_改变下游请求的操作符"><a class="anchor" href="#_改变下游请求的操作符"></a>改变下游请求的操作符</h5>
<div class="paragraph">
<p>有一点要记住的是，在订阅层表达的请求 <strong>可以</strong> 被上游链中的每个操作符重新调整。一个范例就是 <code>buffer(N)</code> 操作符：如果它接收到 <code>request(2)</code>，则解释为需要 <strong>两个完整缓冲区</strong>。因此，由于缓冲区需要 <code>N</code> 个元素才能被视为已满足请求，因此 <code>buffer</code> 操作符将请求重新调整为 <code>2 x N</code>。</p>
</div>
<div class="paragraph">
<p>你可能还注意到有些操作符采用名为 <code>prefetch</code> 的 <code>int</code> 输入参数的形式。这是另一类修改下游请求的操作符。它们通常用于处理内部序列，从输入的每个元素（如 <code>flatMap</code>）中派生出 <code>Publisher</code>。</p>
</div>
<div class="paragraph">
<p><strong>Prefetch</strong> 是对这些内部序列发出的初始请求进行调整的一种方法。如果未指定，这些操作符大多都以 <code>32</code> 的需求开始。</p>
</div>
<div class="paragraph">
<p>这些操作符通常还实现了 <strong>补充优化</strong>：一旦操作符看到75%的预取请求已完成，它将从上游重新请求75%。这是一种启发式优化，使这些操作符能够主动预测即将到来的请求。</p>
</div>
<div class="paragraph">
<p>最后，有两个操作符可以让你直接调整请求：<code>limitRate</code> 和 <code>limitRequest</code>。</p>
</div>
<div class="paragraph">
<p><code>limitRate(N)</code> 对下游请求进行拆分，以便将其分批次向上游传播。例如，对 <code>limitRate(10)</code> 发出 <code>100</code> 的请求会导致最多 <code>10</code> 个请求，分为 <code>10</code> 个批次传播到上游。注意，在这种形式下，<code>limitRate</code> 实际上实现了前面讨论的补充优化。</p>
</div>
<div class="paragraph">
<p>该操作符有一个可以让你调整补充数量（称为 <code>lowTide</code>）的形式：<code>limitRate(highTide, lowTide)</code>。选择 <code>lowTide</code> 为 <code>0</code> 将导致 <strong>严格的</strong> 批次 <code>highTide</code> 请求，而不是由补充策略进一步调整批次。</p>
</div>
<div class="paragraph">
<p>另一方面，<code>limitRequest(N)</code> <strong>限制</strong> 将下游请求的最大请求量。它将请求累加到 <code>N</code>。如果单个 <code>request</code> 没有超过总的请求 <code>N</code>，则该特定请求将完全传播到上游。在源发出该请求量后，<code>limitRequest</code> 将序列视为已完成，向下游发送 <code>onComplete</code> 信号，并取消源。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producing"><a class="anchor" href="#producing"></a>4.4. 以编程方式创建序列</h3>
<div class="paragraph">
<p>在这一节中，我们将通过以编程方式定义其关联的事件（<code>onNext</code>，<code>onError</code>，和 <code>onComplete</code>）来介绍 <code>Flux</code> 或 <code>Mono</code> 的创建。所有这些方法都有一个共同点，即它们暴露了一个API来触发我们称之为 <strong>sink</strong> 的事件。实际上有一些sink的形式，稍后我们将介绍。</p>
</div>
<div class="sect3">
<h4 id="producing.generate"><a class="anchor" href="#producing.generate"></a>4.4.1. 同步 <code>generate</code></h4>
<div class="paragraph">
<p><code>Flux</code> 的最简单的编程创建形式是通过具有生成器功能的 <code>generate</code> 方法。</p>
</div>
<div class="paragraph">
<p>这用于 <strong>synchronous</strong> 和 <strong>一对一</strong> 发射，这意味着该sink是一个 <code>SynchronousSink</code>，并且每次回调调用最多只能调用其 <code>next()</code> 方法一次。然后你可以另外调用 <code>error(Throwable)</code> 或 <code>complete()</code>，但这是可选的。</p>
</div>
<div class="paragraph">
<p>最有用的形式可能是一种能让你保留一个状态，你可以在你sink的使用中参考这个状态来决定下一步发出什么。然后生成器函数变成了 <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code>，其中 <code>&lt;S&gt;</code> 是状态对象的类型。你必须为初始状态提供一个 <code>Supplier&lt;S&gt;</code>，你的生成器函数现在每轮都会返回一个新的状态。</p>
</div>
<div class="paragraph">
<p>例如，你可以使用 <code>int</code> 作为状态：</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. 基于状态 <code>generate</code> 的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      sink.next("3 x " + state + " = " + 3*state); <i class="conum" data-value="2"></i><b>(2)</b>
      if (state == 10) sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
      return state + 1; <i class="conum" data-value="4"></i><b>(4)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们提供初始的状态值为0。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们用状态来选择要发出什么（3的乘法表中的一行）。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们还可以用它来选择什么时候停止。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们返回一个新的状态，在下一个调用中使用（除非这个序列在这个调用中终止）。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码生成3的乘法表，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你还可以使用可变的 <code>&lt;S&gt;</code>。例如，上面的例子可以使用一个单独的 <code>AtomicLong</code> 作为状态来重写，在每一轮对其进行修改：</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. 可变状态形式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这次，我们生成一个可变的对象作为状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们在这里改变状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们返回 <strong>相同</strong> 实例作为新状态。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的状态对象需要清理一些资源，请使用 <code>generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)</code> 形式来清理最后的状态实例。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的例子使用来包含一个 <code>Consumer</code> 的 <code>generate</code> 方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new,
      (state, sink) -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    }, (state) -&gt; System.out.println("state: " + state)); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>同样，我们生成一个可变对象作为状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们在这里改变状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们返回 <strong>相同</strong> 实例作为新状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们把最后一个状态值（11）视为这个 <code>Consumer</code> lambda的输出。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在包含数据库连接或其他资源的状态需要在进程结束时处理的情况下，<code>Consumer</code> lambda可以关闭连接或以其它方式处理任何应在进程结束时完成的任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="producing.create"><a class="anchor" href="#producing.create"></a>4.4.2. 异步和多线程：<code>create</code></h4>
<div class="paragraph">
<p><code>create</code> 是一种更高级的编程方式创建 <code>Flux</code> 的形式，它适合每轮多次发出，甚至来自多个线程。</p>
</div>
<div class="paragraph">
<p>它暴露了一个 <code>FluxSink</code> 及其 <code>next</code>，<code>error</code> 和 <code>complete</code> 方法。与 <code>generate</code> 相反，它没有基于状态的形式。但是，它可以在回调中触发多线程事件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>create</code> 将现有的API和响应式世界桥接起来非常有用 - 例如基于监听器的异步API。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>create</code> <strong>不能使你的代码并行化你，也不能使其异步化</strong>，即使它 <strong>可以</strong> 与异步API一起使用。如果在 <code>create</code> lambda中阻塞了，则会使自己陷入死锁和类似副作用中。即使使用了 <code>subscribeOn</code>，也需要警惕，即长时间阻塞的 <code>create</code> lambda（比如无限循环的调用 <code>sink.next(t)</code>）会锁住管道：这些请求永远不会执行，因为循环会耗尽应运行它们的线程。使用 <code>subscribeOn(Scheduler, false)</code> 的形式：<code>requestOnSeparateThread = false</code> 将使用 <code>Scheduler</code> 线程来进行 <code>create</code>，并且仍然可以通过在原始的线程中执行 <code>request</code> 来让数据流动。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>假设你使用了基于监听器的API。它按块处理数据，并有两个事件：（1）数据块已准备就绪；（2）处理已完成（终止事件），如 <code>MyEventListener</code> 接口所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface MyEventListener&lt;T&gt; {
    void onDataChunk(List&lt;T&gt; chunk);
    void processComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>create</code> 将其桥接成 <code>Flux&lt;T&gt;</code> 中：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register( <i class="conum" data-value="4"></i><b>(4)</b>
      new MyEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>桥接到 <code>MyEventListener</code> API</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>块中的每个元素都会成为 <code>Flux</code> 中的一个元素。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>processComplete</code> 事件被转换为 <code>onComplete</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>所有这些都是在 <code>myEventProcessor</code> 执行时异步完成的。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>此外，由于 <code>create</code> 可以桥接异步API并管理背压，所以你可以通过声明 <code>OverflowStrategy</code> 来细化背压的行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> 完全忽略下游背压请求。当下游队列满时，可能会产生 <code>IllegalStateException</code>。</p>
</li>
<li>
<p><code>ERROR</code> 当下游无法跟上时，发出 <code>IllegalStateException</code> 信号。</p>
</li>
<li>
<p><code>DROP</code> 如果下游还没有准备好接收信号，则丢弃传入的信号。</p>
</li>
<li>
<p><code>LATEST</code> 让下游只能获得来自上游的最新信号。</p>
</li>
<li>
<p><code>BUFFER</code>（默认值）在下游无法跟上时，缓冲所有的信号（这将无限制的缓冲，可能会导致 <code>OutOfMemoryError</code>）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Mono</code> 也有一个 <code>create</code> 生成器。<code>Mono</code> 创建的 <code>MonoSink</code> 不允许多次发出。它将在第一个信号之后丢弃所有信号。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_异步单线程push"><a class="anchor" href="#_异步单线程push"></a>4.4.3. 异步单线程：<code>push</code></h4>
<div class="paragraph">
<p><code>push</code> 介于 <code>generate</code> 和 <code>create</code> 之间，适用于处理来自单个生产者的事件。从某种意义上说，它类似于 <code>create</code>，因为它也可以是异步的，并且可以使用 <code>create</code> 所支持的任何溢出策略来管理背压。但是，<strong>只能有一个生产线程</strong> 可以调用 <code>next</code>，<code>complete</code> 或者 <code>error</code>。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; {
    myEventProcessor.register(
      new SingleThreadEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }

        public void processError(Throwable e) {
            sink.error(e); <i class="conum" data-value="4"></i><b>(4)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>桥接到 <code>SingleThreadEventListener</code> API。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用单个监听器线程中的 <code>next</code> 将事件推送到 sink。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>由同一监听器线程生成的 <code>complete</code> 事件。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>error</code> 事件也是由同一监听器线程生成的。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_混合式推拉模型"><a class="anchor" href="#_混合式推拉模型"></a>混合式推/拉模型</h5>
<div class="paragraph">
<p>大多数响应式操作符，比如 <code>create</code>，都遵循混合的 <strong>推/拉</strong> 模型。我们的意思是，尽管大多数处理都是异步的（建议使用 <em>推</em> 方法），但也有一个小的 <em>拉</em> 组件：请求。</p>
</div>
<div class="paragraph">
<p>从源来看，消费者从源 <em>拉</em> 数据，直到第一次请求之前，它不会发出任何东西。只要有可用的数据时，源会向消费者 <em>推</em> 送数据，但会在其请求数量的范围内。</p>
</div>
<div class="paragraph">
<p>注意，<code>push()</code> 和 <code>create()</code> 都允许设置一个 <code>onRequest</code> 消费者，以便于管理请求量，并确保只有当有待处理的请求时，才将数据推送到sink中。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myMessageProcessor.register(
      new MyMessageListener&lt;String&gt;() {

        public void onMessage(List&lt;String&gt; messages) {
          for(String s : messages) {
            sink.next(s); <i class="conum" data-value="3"></i><b>(3)</b>
          }
        }
    });
    sink.onRequest(n -&gt; {
        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <i class="conum" data-value="1"></i><b>(1)</b>
        for(String s : message) {
           sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
        }
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>请求时轮询消息。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果消息立即可用，将其推送到接收器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>稍后异步到达的其余消息也将被传递。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_在_push_或_create_之后清理"><a class="anchor" href="#_在_push_或_create_之后清理"></a>在 <code>push()</code> 或 <code>create()</code> 之后清理</h5>
<div class="paragraph">
<p>两个回调，<code>onDispose</code> 和 <code>onCancel</code>，在取消或终止时执行任何清理。<code>onDispose</code> 可用于 <code>Flux</code> 完成、错误或取消时执行清理。<code>onCancel</code> 可以用于在使用 <code>onDispose</code> 执行清理之前，执行任何特定于取消的操作。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    sink.onRequest(n -&gt; channel.poll(n))
        .onCancel(() -&gt; channel.cancel()) <i class="conum" data-value="1"></i><b>(1)</b>
        .onDispose(() -&gt; channel.close())  <i class="conum" data-value="2"></i><b>(2)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>onCancel</code> 首先被调用，仅用于取消信号。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>完成、错误或取消信号时调用 <code>onDispose</code>。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_处理"><a class="anchor" href="#_处理"></a>4.4.4. 处理</h4>
<div class="paragraph">
<p><code>handle</code> 方法有点不同：它是一个实例方法，意味着它被链接到一个现有的源（就像常见的操作符）上。它存在于 <code>Mono</code> 和 <code>Flux</code> 中。</p>
</div>
<div class="paragraph">
<p>它靠近于 <code>generate</code>，从某种意义上说，它使用 <code>SynchronousSink</code> 并只允许逐个的发出。但是，<code>handle</code> 可以用来从每个源元素中生成一个任意值，可能会跳过一些元素。这样，它可以作为 <code>map</code> 和 <code>filter</code> 的组合。handle的方法签名如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;R&gt; handle(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一个例子。响应式流规范不允许序列中的值为 <code>null</code>。但是你想使用一个预先存在的方法作为map函数来执行 <code>map</code>，而该方法有时返回null怎么办？</p>
</div>
<div class="paragraph">
<p>例如，下面的方法可以安全地应用于整数源：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String alphabet(int letterNumber) {
	if (letterNumber &lt; 1 || letterNumber &gt; 26) {
		return null;
	}
	int letterIndexAscii = 'A' + letterNumber - 1;
	return "" + (char) letterIndexAscii;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以使用 <code>handle</code> 来删除任何空值：</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. <code>handle</code> 用于 "映射和消除null值" 的场景</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -&gt; {
        String letter = alphabet(i); <i class="conum" data-value="1"></i><b>(1)</b>
        if (letter != null) <i class="conum" data-value="2"></i><b>(2)</b>
            sink.next(letter); <i class="conum" data-value="3"></i><b>(3)</b>
    });

alphabet.subscribe(System.out::println);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>映射到字母。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果 “map函数” 返回null&#8230;&#8203;.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>通过不调用 <code>sink.next</code> 来过滤掉它。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>将打印出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>M
I
T</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schedulers"><a class="anchor" href="#schedulers"></a>4.5. 线程和调度器</h3>
<div class="paragraph">
<p>Reactor，就像RxJava一样，可以被认为是 <strong>可并发的</strong>。也就是说，并没有强制的并发模型。相反，它让开发人员掌握主动权。然而这并不妨碍框架帮你解决并发问题。</p>
</div>
<div class="paragraph">
<p>获得 <code>Flux</code> 或 <code>Mono</code> 并不一定意味着它要在特定的线程运行。相反，大多数操作符继续在上一个操作符执行的 <code>Thread</code> 中工作。除非指定，否则最上面的操作符（源）本身运行在调用了 <code>subscribe()</code> 的 <code>Thread</code> 上。下面的示例在一个新的线程上运行 <code>Mono</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) throws InterruptedException {
  final Mono&lt;String&gt; mono = Mono.just("hello "); <i class="conum" data-value="1"></i><b>(1)</b>

  Thread t = new Thread(() -&gt; mono
      .map(msg -&gt; msg + "thread ")
      .subscribe(v -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
          System.out.println(v + Thread.currentThread().getName()) <i class="conum" data-value="3"></i><b>(3)</b>
      )
  )
  t.start();
  t.join();

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Mono&lt;String&gt;</code> 在 <code>main</code> 线程中组装。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>但是，它是在 <code>Thread-0</code> 线程中订阅的。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>因此，<code>map</code> 和 <code>onNext</code> 回调实际都是在 <code>Thread-0</code> 中运行。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>hello thread Thread-0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在Reactor中，执行模型和执行的位置由使用的 <code>Scheduler</code> 决定。
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"><code>Scheduler</code></a>具有类似于 <code>ExecutorService</code> 的调度职责，但有一个专门的抽象使其可以做更多的事情，尤其是作为一个时钟和更广的范围实现（虚拟时间测试，波动或立即调度等）。</p>
</div>
<div class="paragraph">
<p>The <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"><code>Schedulers</code></a>
类有可以访问执行上下文的静态方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无执行上下文（<code>Schedulers.immediate()</code>）：在处理时，提交的 <code>Runnable</code> 将被直接执行，有效地在当前的 <code>Thread</code> 上运行它们（可以视为“空对象”或无操作的 <code>Scheduler</code>）。</p>
</li>
<li>
<p>一个单一可重用的线程（<code>Schedulers.single()</code>）。注意，此方法对所有调用者会重用相同的线程，直到调度器销毁掉。如果你希望每次调用都有一个特定的线程，请使用 <code>Schedulers.newSingle()</code> 即可。</p>
</li>
<li>
<p>一个无界的弹性线程池（<code>Schedulers.elastic()</code>）。由于 <code>Schedulers.boundedElastic()</code> 的引入，这个线程池不再是首选的了，因为它容易隐藏背压问题而导致线程过多（见下文）。</p>
</li>
<li>
<p>一个有边界的弹性线程池（<code>Schedulers.boundedElastic()</code>）。就像它的前身 <code>elastic()</code> 一样，它根据需要创建新的和复用空闲的线程池。空闲时间过长（默认值为60s）的线程池也会被销毁。与之前的 <code>elastic()</code> 不同的是，创建可支持的线程数有上限（默认为CPU核数 x 10）。最多可提交10万个任务，达到上限后，将在线程可用时重新调度任务（当延时调度时，延迟在线程可用时开始）。对于I/O阻塞任务，这是更好的选择。<code>Schedulers.boundedElastic()</code> 是一种在自己线程上进行阻塞处理的便捷方式，它不会占用其它的资源。见<a href="#faq.wrap-blocking">如何包装一个同步阻塞调用？</a>，但不会给系统带来太多新的线程压力。</p>
</li>
<li>
<p>一个固定worker池，调整为并行工作（<code>Schedulers.parallel()</code>)。它创建和CPU核数相等的worker。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，你可以用现有的 <code>ExecutorService</code> 通过 <code>Schedulers.fromExecutorService(ExecutorService)</code> 创建一个 <code>Scheduler</code>。（你也可以使用 <code>Executor</code> 进行创建，但不建议这样做。）</p>
</div>
<div class="paragraph">
<p>你也可以通过使用 <code>newXXX</code> 方法创建各种调度器类型的新实例。例如，<code>Schedulers.newParallel(yourScheduleName)</code> 创建了一个新的并行调度器，命名为 <code>yourScheduleName</code>。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然 <code>boundedElastic</code> 是为了在无法避免的情况下帮助处理遗留的阻塞代码，但 <code>single</code> 和 <code>parallel</code> 不是。因此，使用Reactor阻塞API（在默认的单调度器和并行调度器内 <code>block()</code>，<code>blockFirst()</code>，<code>blockLast()</code>（以及迭代 <code>toIterable()</code> 或 <code>toStream()</code>））会导致抛出 <code>IllegalStateException</code> 。</p>
</div>
<div class="paragraph">
<p>通过创建实现 <code>NonBlocking</code> 标记接口的 <code>Thread</code> 实例，自定义的 <code>调度器</code> 也可以被标记为“非阻塞”。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一些操作符默认使用 <code>Schedulers</code> 中特定的调度器（通常会给你提供一个不同的调度器）。例如，调用 <code>Flux.interval(Duration.ofMillis(300))</code> 工厂方法会每隔300ms产生一个 <code>Flux&lt;Long&gt;</code>。默认情况下，这是由 <code>Schedulers.parallel()</code> 启用的。下面这一行将调度器改为类似于 `Schedulers.single()`的新实例。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Reactor提供了两种方式来切换响应式链中的执行上下文（或 <code>Scheduler</code> ）: <code>publishOn</code> 和 <code>subscribeOn</code>。两者都取一个 <code>Scheduler</code>，并让你将执行上下文切换到该调度器。但是 <code>publishOn</code> 在链中的位置是很重要的，然而 <code>subscribeOn</code> 的位置却是无关紧要的。要理解这个区别，你首先要记住<a href="#reactive.subscribe">订阅之前什么都不会发生</a>。</p>
</div>
<div class="paragraph">
<p>在Reactor中，当你用链接操作符时，你可以根据需要在内部封装尽可能多的 <code>Flux</code> 和 <code>Mono</code> 实现。一旦你订阅了，一个 <code>Subscriber</code> 对象的链就会创建出来，向后（沿着链向上）到第一个生产者。这实际上是对你隐藏掉的。你能看到的只是外层到 <code>Flux</code> (或 <code>Mono</code>)和 <code>Subscription</code>，但是这些中间的操作符的订阅才是真正的工作。</p>
</div>
<div class="paragraph">
<p>有了这些知识，我们可以仔细看看 <code>publishOn</code> 和 <code>subscribeOn</code> 操作符：</p>
</div>
<div class="sect3">
<h4 id="_publishon_方法"><a class="anchor" href="#_publishon_方法"></a>4.5.1. <code>publishOn</code> 方法</h4>
<div class="paragraph">
<p>和其它操作符一样，<code>publishOn</code> 应用在订阅链的中间位置。它接收来自上游的信号，并在下游重放，同时在相关的 <code>Scheduler</code> 中某个worker执行回调。因此它 <strong>影响到后续操作符的执行</strong>（直到链中的另一个 <code>publishOn</code> ），具体如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将执行上下文改为由 <code>Scheduler</code> 选择的一个 <code>Thread</code></p>
</li>
<li>
<p>根据规范， <code>onNext</code> 依次调用，所以这就占用了一个线程</p>
</li>
<li>
<p>除非它们在特定的 <code>Scheduler</code> 上工作，否则在 <code>publishOn</code> 之后的操作符将继续在同一线程上执行</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的示例使用了 <code>publishOn</code> 方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .publishOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个包含四个 <code>Thread</code> 实例的新的 <code>Scheduler</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个 <code>map</code> 操作符在&lt;5&gt;的匿名线程中执行。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>publishOn</code> 将整个序列切换到从&lt;1&gt;中的 <code>Thread</code> 上。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个 <code>map</code> 操作符在&lt;1&gt;的 <code>Thread</code> 上运行。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这个匿名 <code>Thread</code> 是发生 <em>订阅</em> 地方，打印是在最近的执行上下文中发生的，也就是 <code>publishOn</code> 中的那个。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_subscribeon_方法"><a class="anchor" href="#_subscribeon_方法"></a>4.5.2. <code>subscribeOn</code> 方法</h4>
<div class="paragraph">
<p>当向下的链被构造时，<code>subscribeOn</code> 应用在订阅处理上。因此，无论你将 <code>subscribeOn</code> 放在链中的哪个位置，<strong>始终会影响到源排放的上下文</strong>。然而，这不会影响到后续调用 <code>publishOn</code> 的行为&#8201;&#8212;&#8201;它们仍将为其之后的链执行上下文切换。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>改变 <strong>整个链</strong> 所订阅的 <code>Thread</code></p>
</li>
<li>
<p>从 <code>Scheduler</code> 选择一个线程</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
只有链中的最早的 <code>subscribeOn</code> 调用才会被实际考虑在内。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的例子使用了 <code>subscribeOn</code> 方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .subscribeOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个包含四个 <code>Thread</code> 实例的新的 <code>Scheduler</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个 <code>map</code> 操作符运行在四个线程中之一&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;因为 <code>subscribeOn</code> 从订阅时间（&lt;5&gt;）开始就会切换整个序列。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个 <code>map</code> 也运行在相同的线程上。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这个匿名的 <code>Thread</code> 是最初发生 _订阅_的地方，但 <code>subscribeOn</code> 立即将其转移到调度器的四个线程之一。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error.handling"><a class="anchor" href="#error.handling"></a>4.6. 错误处理</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
快速查看关于错误处理的操作符，参看<a href="#which.errors">相关操作符决策树</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在响应式流中，错误是终止事件。一旦错误发生，就会停止序列，并沿着操作符链向下传播到最后一步，即你定义的 <code>Subscriber</code> 及其 <code>onError</code> 方法。</p>
</div>
<div class="paragraph">
<p>此类错误仍应在应用程序层面处理。例如，你可以在UI中显示错误通知或者在REST端点中发送一个有意义的错误负载。因此，订阅者的 <code>onError</code> 方法应该总是被定义的。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
如果没有定义，<code>onError</code> 会抛出一个 <code>UnsupportedOperationException</code> 异常。你可以使用 <code>Exceptions.isErrorCallbackNotImplemented</code> 方法进一步检测和分类。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor还提供了处理链中间处理错误的替代方法，即错误操作符，下面的例子显示了如何做到这一点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just(1, 2, 0)
    .map(i -&gt; "100 / " + i + " = " + (100 / i)) //这将触发一个0的错误
    .onErrorReturn("Divided by zero :("); // 错误处理例子</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在学习错误处理操作符之前，你必须记住 <em>响应式序列中的任何错误都是一个终止事件</em>。即使使用了错误处理操作符，它也不会让原来序列继续进行。相反，它将 <code>onError</code> 信号转换为一个新的序列（降级序列）的开始。换句话说，它会替换了 <em>上游</em> 终止序列。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们可以逐一考虑每一种错误处理的方式。适当的时候，我们将与命令式编程的 <code>try</code> 模式并行使用。</p>
</div>
<div class="sect3">
<h4 id="_错误处理操作符"><a class="anchor" href="#_错误处理操作符"></a>4.6.1. 错误处理操作符</h4>
<div class="paragraph">
<p>你可能对用try-catch块捕获异常的几种方法比较熟悉。
最值得注意的是，这些方法包含以下几种：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>捕获并返回一个静态默认值。</p>
</li>
<li>
<p>捕获异常并执行一个降级方法。</p>
</li>
<li>
<p>捕获异常并动态地计算一个降级的值。</p>
</li>
<li>
<p>捕获异常，封装成一个 <code>BusinessException</code>，然后重新对外抛出。</p>
</li>
<li>
<p>捕获异常，打印错误的具体信息，并重新对外抛出异常。</p>
</li>
<li>
<p>使用 <code>finally</code> 块或Java 7以上支持的 &#8220;try-with-resource&#8221; 语法清理资源。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Reactor中，所有的这些方法都以错误处理操作符的形式且具有相同的效果。
在深入这些操作符之前，我们首先要在响应式链和try-catch块之间建立对应的关系。</p>
</div>
<div class="paragraph">
<p>当订阅时，在链的末端的 <code>onError</code> 回调类似于一个 <code>catch</code> 块。在这里，当抛出一个 <code>Exception</code> 时，执行会跳转到catch，如下面示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; s = Flux.range(1, 10)
    .map(v -&gt; doSomethingDangerous(v)) <i class="conum" data-value="1"></i><b>(1)</b>
    .map(v -&gt; doSecondTransform(v)); <i class="conum" data-value="2"></i><b>(2)</b>
s.subscribe(value -&gt; System.out.println("RECEIVED " + value), <i class="conum" data-value="3"></i><b>(3)</b>
            error -&gt; System.err.println("CAUGHT " + error) <i class="conum" data-value="4"></i><b>(4)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>执行了可能引发异常的转换。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果一切顺利，则执行第二次转换。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>每个成功转换的值都会打印出来。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>当发生错误时，终止序列且显示错误信息。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的例子在概念上与下面的try-catch块类似：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
    for (int i = 1; i &lt; 11; i++) {
        String v1 = doSomethingDangerous(i); <i class="conum" data-value="1"></i><b>(1)</b>
        String v2 = doSecondTransform(v1); <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果这里出现异常</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;跳过循环的其余部分&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; 直接执行到这里。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>既然我们已经建立了对应的关系，我们就可以看不同的错误处理情况及其等效的操作符。</p>
</div>
<div class="sect4">
<h5 id="_静态降级的值"><a class="anchor" href="#_静态降级的值"></a>静态降级的值</h5>
<div class="paragraph">
<p><code>onErrorReturn</code> 等效于“<code>捕获并返回一个静态默认值</code>”。
下面的例子显示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子展示了在Reactor中相同的效果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你还可以选择在异常上应用一个 <code>Predicate</code> 来决定是否恢复，如下面的例子所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -&gt; e.getMessage().equals("boom10"), "recovered10"); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>仅当异常信息为 <code>"boom10"</code> 时返回</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_降级方法"><a class="anchor" href="#_降级方法"></a>降级方法</h5>
<div class="paragraph">
<p>如果你想要有多个默认值，并且有其他的（更安全的）方式处理数据，你可以使用 <code>onErrorResume</code>。这相当于 &#8220;捕获异常并执行一个降级方法&#8221;。</p>
</div>
<div class="paragraph">
<p>例如，如果你名义上的进程正在从外部且不可靠的服务中获取数据，但你也保留了一个相同数据的本地缓存，而这些数据 <em>也许</em> 有点过期但是更可靠，你可以做以下操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子展示了在Reactor中相同的效果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("key1", "key2")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .onErrorResume(e -&gt; getFromCache(k)) <i class="conum" data-value="2"></i><b>(2)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>对于每个键，异步调用外部服务。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果外部服务调用失败，降级获取该键的缓存中。注意，无论源的错误是什么 <code>e</code> 异常，我们总是应用相同的降级。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>和 <code>onErrorReturn</code> 一样，<code>onErrorResume</code> 有不同的形式让你根据异常的类型或 <code>Predicate</code> 来过滤哪些异常需要降级。事实上，它需要一个 <code>Function</code>，这也让你可以根据遇到的不同的错误来选择不同的降级序列来进行切换。下面的例子显示了如何做到这一点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -&gt; callExternalService(k)
        .onErrorResume(error -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            if (error instanceof TimeoutException) <i class="conum" data-value="2"></i><b>(2)</b>
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  <i class="conum" data-value="3"></i><b>(3)</b>
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); <i class="conum" data-value="4"></i><b>(4)</b>
        })
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该函数可以动态选择如何继续。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果源超时，访问本地缓存。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果源中该键为未知，则创建新的对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>其它的所有情况下，&#8220;重新抛出异常&#8221;。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_动态降级的值"><a class="anchor" href="#_动态降级的值"></a>动态降级的值</h5>
<div class="paragraph">
<p>即使你没有其它（更安全的）的数据处理的方式，你可能也想从你收到的异常中计算出一个降级的值。这就相当于 &#8220;捕获异常并动态地计算一个降级的值&#8221;。</p>
</div>
<div class="paragraph">
<p>例如，如果你的返回类型（<code>MyWrapper</code>）有一个专门用来保存异常的形式（参考 <code>Future.complete(T success)</code> 与 <code>Future.completeExceptionally(Throwable error)</code> ），你可以实例化错误保持变量并传递异常。</p>
</div>
<div class="paragraph">
<p>一个命令式编程示例如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>onErrorResume</code>，你可以像降级方法解决方案以相同的方式进行响应式操作，略作修改，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">erroringFlux.onErrorResume(error -&gt; Mono.just( <i class="conum" data-value="1"></i><b>(1)</b>
        MyWrapper.fromError(error) <i class="conum" data-value="2"></i><b>(2)</b>
));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>因为你期望 <code>MyWrapper</code> 来表示错误，所以你需要为 <code>onErrorResume</code> 获取一个 <code>Mono&lt;MyWrapper&gt;</code>，我们用 <code>Mono.just()</code> 来实现。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们需要计算出异常值。这里，我们通过使用相关的 `MyWrapper`工厂方法对异常进行包装来实现。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_捕获并重新抛出异常"><a class="anchor" href="#_捕获并重新抛出异常"></a>捕获并重新抛出异常</h5>
<div class="paragraph">
<p>"捕获异常，封装成一个 <code>BusinessException</code>，然后重新对外抛出”，在命令式编程里面看起来就像下面这样：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在 &#8220;降级方法&#8221; 示例中， <code>flatMap</code> 中的最后一行给了我们一个提示，为我们实现同样的响应式操作，具体如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorResume(original -&gt; Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，有一种更直接的方法，可以使用 <code>onErrorMap</code> 达到同样的效果：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorMap(original -&gt; new BusinessException("oops, SLA exceeded", original));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_侧面记录日志或响应"><a class="anchor" href="#_侧面记录日志或响应"></a>侧面记录日志或响应</h5>
<div class="paragraph">
<p>如果你想让错误继续传播，但仍想在不修改序列的情况下对错误做出响应（例如记录日志），你可以使用 <code>doOnError</code> 操作符。这相当于 &#8220;捕获异常，打印错误的具体信息，并重新对外抛出异常&#8221; 的模式，如下面的例子所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>doOnError</code> 操作符以及所有以 <code>doOn</code> 为前缀的操作符，有时被称为 &#8220;侧面效应&#8221;。它们让你可以在不修改序列事件的情况下窥测到序列内部的事件。</p>
</div>
<div class="paragraph">
<p>就像前面的命令式编程例子一样，下面的例子仍然会传播错误，但至少可以确保我们记录到外部服务发生了故障。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">LongAdder failureStat = new LongAdder();
Flux&lt;String&gt; flux =
Flux.just("unknown")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .doOnError(e -&gt; {
            failureStat.increment();
            log("uh oh, falling back, service failed for key " + k); <i class="conum" data-value="2"></i><b>(2)</b>
        })
        <i class="conum" data-value="3"></i><b>(3)</b>
    );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>可能失败的外部服务调用&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;被装饰了日志和统计的侧面效果&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;之后，它仍然以错误终止，除非我们在这里使用错误恢复操作符。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>我们还可以设想，我们有统计计数器增加来作为第二个错误的侧面效应。</p>
</div>
</div>
<div class="sect4">
<h5 id="_使用resources和fianlly块"><a class="anchor" href="#_使用resources和fianlly块"></a>使用Resources和Fianlly块</h5>
<div class="paragraph">
<p>最后一个与命令式编程对应的是清理，通过使用 &#8220;使用 <code>finally</code> 块&#8221; 或Java 7以上支持的 &#8220;try-with-resource&#8221; 语法清理资源，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. 命令式地使用finally</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 15. 命令式地使用try-with-resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>两者都有对应的响应式操作：<code>doFinally</code> 和 <code>using</code>。</p>
</div>
<div class="paragraph">
<p><code>doFinally</code> 是关于你希望在序列终止（用 <code>onComplete</code> 或 <code>onError</code>）时或被取消时执行的侧面作用。它给了你一个提示，说明是哪种类型的终止方式触发侧面作用的。下面的例子显示了如何使用 <code>doFinally</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">响应式的finally: <code>doFinally()</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux&lt;String&gt; flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -&gt; stats.startTimer())
    .doFinally(type -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
        stats.stopTimerAndRecordTiming();<i class="conum" data-value="2"></i><b>(2)</b>
        if (type == SignalType.CANCEL) <i class="conum" data-value="3"></i><b>(3)</b>
          statsCancel.increment();
    })
    .take(1); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doFinally</code> 消费终止类型的 <code>SignalType</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>与 <code>finally</code> 代码块类似，我们总是记录时间。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>这里我们也只在取消的情况下进行增量统计。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>take(1)</code> 在发射一项元素后取消。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>另一方面，<code>using</code> 处理了 <code>Flux</code> 来自于某资源的情况，且在处理过程中必须对资源进行操作。在下面的例子中，我们用 <code>Disposable</code> 替换 &#8220;try-with-resource&#8221; 中的 <code>AutoCloseable</code> 接口：</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. 可丢弃的资源</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们可以做相当于 “<code>try-with-resource</code>” 的响应式操作了，看起来像下面这样：</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. 响应式的try-with-resource: <code>using()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.using(
        () -&gt; disposableInstance, <i class="conum" data-value="1"></i><b>(1)</b>
        disposable -&gt; Flux.just(disposable.toString()), <i class="conum" data-value="2"></i><b>(2)</b>
        Disposable::dispose <i class="conum" data-value="3"></i><b>(3)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一个lambda生成资源。这里，我们返回我们mock的 <code>Disposable</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二个lambda处理资源，返回一个 <code>Flux&lt;T&gt;</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当第二步骤中 <code>Flux</code> 终止或被取消时，第三个lambda将被执行，以清理资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>订阅并执行序列后，<code>isDisposed</code> 自动变成 <code>true</code>。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_演示_onerror_的终止方面"><a class="anchor" href="#_演示_onerror_的终止方面"></a>演示 <code>onError</code> 的终止方面</h5>
<div class="paragraph">
<p>为了证明所有这些操作符都会在错误发生时导致上游原始序列终止，我们可以用一个更直观的例子 <code>Flux.interval</code> 来说明。 <code>interval</code> 操作符每x个时间单位周期增加 <code>Long</code> 值。下面的例子使用了 <code>interval</code> 操作符：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注意，<code>interval</code> 默认是在 <strong>timer</strong> <code>Scheduler</code> 上执行的。如果我们想在main类中运行该例子，我们需要在这里加一段 <code>sleep</code> 调用，这样应用程序不会在没有产生任何值的情况下立即退出。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的例子每250ms打印出一行，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>tick 0
tick 1
tick 2
Uh oh</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使多了一秒的运行时间，<code>interval</code> 也没有多的周期。这个序列确实被错误终止了。</p>
</div>
</div>
<div class="sect4">
<h5 id="_重试"><a class="anchor" href="#_重试"></a>重试</h5>
<div class="paragraph">
<p>关于错误处理，还有另外一个有趣的操作符，在上一节所述的情况下，你可能会想到使用它。 顾名思义，<code>retry</code> 让你重试产生错误的序列。</p>
</div>
<div class="paragraph">
<p>需要记住的是，它是通过 <strong>重新订阅</strong> 上游的 <code>Flux</code> 来工作的。实际上是一个不同的序列，原始序列仍然是终止的。为了验证这一点，我们依然用前面的例子，并添加 <code>retry(1)</code> 重试一次，而不是使用 <code>onErrorReturn</code>。下面的例子显示了如何做到这一点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(System.out::println, System.err::println); <i class="conum" data-value="2"></i><b>(2)</b>

Thread.sleep(2100); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>elapsed</code> 将每个值与前一个值发出后的持续时间关联起来。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们还想看看什么时候出现 <code>onError</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>确保我们有足够的时间进行4x2的计时周期。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的例子产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>259,tick 0
249,tick 1
251,tick 2
506,tick 0 <i class="conum" data-value="1"></i><b>(1)</b>
248,tick 1
253,tick 2
java.lang.RuntimeException: boom</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从周期0，一个新的 <code>interval</code> 开始。额外的250ms的持续时间为从第四个周期开始，也就是导致异常和后续重试的那个周期。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>从前面的例子可以看到，<code>retry(1)</code> 仅重新订阅了一次原始的 <code>interval</code>，从0开始重新计时。第二次，由于异常依然发生，放弃并向下游传播错误。</p>
</div>
<div class="paragraph">
<p><code>retry</code>（称为 <code>retryWhen</code>）有一个更高级的版本，使用伴随的 <code>Flux</code> 来告知是否应重试特定的故障。为了便于自定义retry的条件，这个伴随的 <code>Flux</code> 被操作符创建但是是由用户自己组装的。</p>
</div>
<div class="paragraph">
<p>伴随的 <code>Flux</code> 是一个 <code>Flux&lt;RetrySignal&gt;</code> ，它被传递给一个 <code>Retry</code> 策略/函数，且作为 <code>retryWhen</code> 的唯一的参数提供。作为用户，你定义该函数并使其返回新的 <code>Publisher&lt;?&gt;</code>。<code>Retry</code> 类是一个抽象类，但如果你想用一个简单的lambda（<code>Retry.from(Function)</code>）来转换伴随的对象，它提供了一个工厂方法。</p>
</div>
<div class="paragraph">
<p>重试周期如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>每次发生错误时（提供重试的可能性），<code>RetrySignal</code> 都会被发送到伴随的 <code>Flux</code> 中，而这个 <code>Flux</code> 已经被你的函数装饰过了。这里的 <code>Flux</code> 可以看到目前为止所有的尝试。<code>RetrySignal</code> 提供了对错误的访问，以及围绕错误的元数据。</p>
</li>
<li>
<p>如果伴随的 <code>Flux</code> 产生一个值，则会发生重试。</p>
</li>
<li>
<p>如果伴随的 <code>Flux</code> 完成，则错误被吞掉，重试循环停止，结果序列也完成。</p>
</li>
<li>
<p>如果伴随的 <code>Flux</code> 产生一个错误（<code>e</code>），重试周期停止并产生带有错误（<code>e</code>）的序列。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>前两种情况的区分很重要。只需完成伴随的就能有效地吞掉错误。考虑一下下面的方式，通过使用 <code>retryWhen</code> 来模仿 <code>retry(3)</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux
    .&lt;String&gt;error(new IllegalArgumentException()) <i class="conum" data-value="1"></i><b>(1)</b>
    .doOnError(System.out::println) <i class="conum" data-value="2"></i><b>(2)</b>
    .retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        companion.take(3))); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这会不断产生错误，调用重试。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>doOnError</code> 可以让我们能够在重试之前记录和看到所有的失败。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Retry</code> 改编自一个非常简单的 <code>Function</code> lambda</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>这里，我们认为前三个错误是可以重试的（<code>take(3)</code>），然后放弃。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>实际上，前面的例子产生一个空的 <code>Flux</code>，但是它成功地完成了。由于在同一个 <code>Flux</code> 上地 <code>retry(3)</code> 会以最近的错误终止，所以这个 <code>retryWhen</code> 例子与 <code>retry(3)</code> 不完全相同。</p>
</div>
<div class="paragraph">
<p>要想达到同样的行为，还需要一些额外的技巧：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
		Flux.&lt;String&gt;error(new IllegalArgumentException())
				.doOnError(e -&gt; errorCount.incrementAndGet())
				.retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
						companion.map(rs -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
							if (rs.totalRetries() &lt; 3) return rs.totalRetries(); <i class="conum" data-value="3"></i><b>(3)</b>
							else throw Exceptions.propagate(rs.failure()); <i class="conum" data-value="4"></i><b>(4)</b>
						})
				));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们通过改编 <code>Function</code> lambda来自定义 <code>Retry</code>，而不是提供一个具体的类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>伴随的对象发出 <code>RetrySignal</code>，它记录了迄今为止的重试次数和最后一次失败的次数。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>为了允许三次重试，我们考虑索引&lt;3并返回一个值来发出（这里我们简单地返回索引）。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>为了在错误中终止序列，我们在这三次重试之后抛出原始异常。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
人们可以用 <code>Retry</code> 中暴露的构建器来实现同样的功能，也可以使用更流畅的重试策略。例如：<code>errorFlux.retryWhen(Retry.max(3));</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以用类似的代码来实现 &#8220;幂等补偿和重试&#8221; 模式，如<a href="#faq.exponentialBackoff">FAQ</a>中所示：
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>core提供的 <code>Retry</code> 辅助工具，<code>RetrySpec</code> 和 <code>RetryBackoffSpec</code>，都允许进行高级定制，如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为可以触发重试的异常设置 <code>filter(Predicate)</code></p>
</li>
<li>
<p>通过 <code>modifyErrorFilter(Function)</code> 修改这样一个先前设置的过滤器</p>
</li>
<li>
<p>触发重试触发器（即延时前后的回退）等副作用，只要重试有效（<code>doBeforeRetry()</code> 和 <code>doAfterRetry()</code> 是附加的）</p>
</li>
<li>
<p>在重试触发器周围触发一个异步的 <code>Mono&lt;Void&gt;</code>，它允许在基本的延迟的基础上添加异步行为，从而进一步延迟触发器（<code>doBeforeRetryAsync</code> 和 <code>doAfterRetryAsync</code> 是附加的）</p>
</li>
<li>
<p>在达到最大尝试次数的情况下，通过 <code>onRetryExhaustedThrow(BiFunction)</code> 自定义异常。默认情况下，使用了 <code>Exceptions.retryExhausted(&#8230;&#8203;)</code>，可以通过 <code>Exceptions.isRetryExhausted(Throwable)</code> 来区分。</p>
</li>
<li>
<p>激活处理 <em>瞬时错误</em> (见下文)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Retry</code> 规范中的瞬时错误处理使用 <code>RetrySignal#totalRetriesInARow()</code>：为了检查是否重试和计算重试延迟，每次发出 <code>onNext</code> 时，使用的索引是一个替代索引且被重置为0。
这样做的后果是，如果重新订阅的数据源在再次失败之前产生了一些数据，那么之前的失败将不计入最大的重试次数。
在指数退避策略的情况下，这也意味着下一次的尝试将回到最小的 <code>Duration</code> 退避，而不是更长的时间。
这对于生存比较久的源来说尤其有用，因为这些源看到的是零星的错误突发（或 <em>瞬时</em> 错误），每次突发都应该用自己的回退来重试。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicInteger errorCount = new AtomicInteger(); <i class="conum" data-value="1"></i><b>(1)</b>
AtomicInteger transientHelper = new AtomicInteger();
Flux&lt;Integer&gt; transientFlux = Flux.&lt;Integer&gt;generate(sink -&gt; {
	int i = transientHelper.getAndIncrement();
	if (i == 10) { <i class="conum" data-value="2"></i><b>(2)</b>
		sink.next(i);
		sink.complete();
	}
	else if (i % 3 == 0) { <i class="conum" data-value="3"></i><b>(3)</b>
		sink.next(i);
	}
	else {
		sink.error(new IllegalStateException("Transient error at " + i)); <i class="conum" data-value="4"></i><b>(4)</b>
	}
})
		.doOnError(e -&gt; errorCount.incrementAndGet());

transientFlux.retryWhen(Retry.max(2).transientErrors(true))  <i class="conum" data-value="5"></i><b>(5)</b>
             .blockLast();
assertThat(errorCount).hasValue(6); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们将统计重试序列中的错误数量。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们 <code>generate</code> 一个有突发错误的源。当计数器达到10时，它将成功完成。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果 <code>transientHelper</code> 原子变量是 <code>3</code> 的倍数时，我们就会发出 <code>onNext</code>，从而结束当前的突发错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在其他情况下，我们会发出一个 <code>onError</code>。这就是3次中的两次，所以2个 <code>onError</code> 突发错误中断了1个 <code>onNext</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>我们在该源上使用 <code>retryWhen</code>，配置最多为2次重试，但是以 <code>transientErrors</code> 模式。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>在结束时，在 <code>errorCount</code> 中登记了 <code>6</code> 个错误后，序列到达 <code>onNext(10)</code> 并完成。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>transientErrors(true)</code>，在第二次突发错误时，将达到配置的最大尝试数 <code>2</code>，并且在发出 <code>onNext(3)</code> 后，序列将失败。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_处理操作符或者函数中的异常"><a class="anchor" href="#_处理操作符或者函数中的异常"></a>4.6.2. 处理操作符或者函数中的异常</h4>
<div class="paragraph">
<p>一般来说，所有的操作符本身都可能包含有可能触发异常或调用用户自定义的回调的代码，这些代码同样可能会失败，所以它们都包含了某种形式的错误处理。</p>
</div>
<div class="paragraph">
<p>根据经验，未经过检查的异常总是通过 <code>onError</code> 进行传播。例如，在 <code>map</code> 函数中抛出一个 <code>RuntimeException</code> 转换为一个 <code>onError</code>，如下代码所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.just("foo")
    .map(s -&gt; { throw new IllegalArgumentException(s); })
    .subscribe(v -&gt; System.out.println("GOT VALUE"),
               e -&gt; System.out.println("ERROR: " + e));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码打印出以下内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>ERROR: java.lang.IllegalArgumentException: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过使用<a href="#hooks-internal">钩子</a>来调整在传递给 <code>onError</code> 之前的 <code>Exception</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然而，Reactor定义了一组被认为是致命的异常（例如 <code>OutOfMemoryError</code>）。参考 <code>Exceptions.throwIfFatal</code> 方法。这些错误意味着Reactor不能继续运行，且将错误抛出而不是传播。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在内部，也有某些情况下，由于并发竞争，可能导致 <code>onError</code> 或 <code>onComplete</code> 条件，未检查的异常依然不能被传播（最明显的是在订阅和请求阶段）。当竞争发生时，不能传播的错误会被 &#8220;丢弃&#8221; 掉。这些情况在某种程度上也可以通过自定义钩子进行管理。参见<a href="#hooks-dropping">删除钩子</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可能会问：&#8220;需检查异常的怎么办？&#8221;</p>
</div>
<div class="paragraph">
<p>例如，如果你需要调用一些声明了 <code>throws</code> 异常的方法，你依然需要在 <code>try-catch</code> 块中处理这些异常。但是，你有几个选择：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>捕获到异常并从中恢复。序列继续正常的进行。</p>
</li>
<li>
<p>捕获异常，将其封装成一个 <em>不检查</em> 的异常，然后将其抛出（中断序列）。<code>Exceptions</code> 工具类可以帮助你解决这个问题（接下来我们会讲到这个问题）。</p>
</li>
<li>
<p>如果你需要返回一个 <code>Flux</code>（例如，在 <code>flatMap</code> 中），那么就用一个产生错误的 <code>Flux</code> 来封装异常，如下所示：<code>return Flux.error(checkedException)</code>。（这个序列也会终止。）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reactor有一个 <code>Exceptions</code> 工具类，你可以用它来确保只有当异常为被检查异常时才会被封装：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果有必要的话，使用 <code>Exceptions.propagate</code> 方法来封装异常。并且会首先调用 <code>throwIfFatal</code> 且不会封装 <code>RuntimeException</code>。</p>
</li>
<li>
<p>使用 <code>Exceptions.unwrap</code> 方法获取原始的未包装的异常（回到响应式特定异常的层次结构的根源）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑下面的 <code>map</code> 的例子，它使用的转换方法可能导致 <code>IOException</code> 异常：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String convert(int i) throws IOException {
    if (i &gt; 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设你在 <code>map</code> 使用该方法。你现在必须显式的捕获到该异常，且你到map函数不能重新对外抛出。所以你可以将其作为 <code>RuntimeException</code> 异常传播到map的 <code>onError</code> 方法中，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; converted = Flux
    .range(1, 10)
    .map(i -&gt; {
        try { return convert(i); }
        catch (IOException e) { throw Exceptions.propagate(e); }
    });</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以后，当订阅前面的 <code>Flux</code> 并对错误做出响应时（例如在用户界面），如果你想对IO异常做一些特殊的事情，你可以将其还原到原始异常。下面的例子显示了如何做到这一点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">converted.subscribe(
    v -&gt; System.out.println("RECEIVED: " + v),
    e -&gt; {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="processors"><a class="anchor" href="#processors"></a>4.7. 处理器</h3>
<div class="paragraph">
<p>Processor是一种特殊的 <code>Publisher</code>，也是 <code>Subscriber</code>。这意味着你可以 <code>subscribe</code> 一个 <code>Processor</code>（通常，它们实现了 <code>Flux</code>），但你也可以调用方法手动将数据注入到序列或终止它。</p>
</div>
<div class="paragraph">
<p>Processor有几种，每一种都有一些特殊的语义，但是在你开始研究它们之前，你需要问自己以下问题：</p>
</div>
<div class="sect3">
<h4 id="_我需要一个processor吗"><a class="anchor" href="#_我需要一个processor吗"></a>4.7.1. 我需要一个Processor吗?</h4>
<div class="paragraph">
<p>大多数时候，你应该尽量避免使用 <code>Processor</code>。它们很难正确使用，而且容易出现一些极端的情况。</p>
</div>
<div class="paragraph">
<p>如果你认为 <code>Processor</code> 比较适合你的情况，请问你自己是否尝试过这两种选择：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>操作符或者组合操作符是否满足要求？（看<a href="#which-operator">我需要哪个操作符？</a>）</p>
</li>
<li>
<p>能否用 <a href="#producing">&#8220;generator&#8221;</a> 操作符代替？（通常，这些操作符用于桥接非响应式的API，提供了一个概念上类似于 <code>Processor</code> 的 &#8220;sink&#8221;，也就是说它允许你用数据手动填充或终止序列）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果在考察了上述的替代方案后，你仍然认为你需要一个 <code>Processor</code>，请阅读 <a href="#processor-overview">可用处理器概述</a> 章节了解不同的实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_sink_外观模式多线程安全生产"><a class="anchor" href="#_使用_sink_外观模式多线程安全生产"></a>4.7.2. 使用 <code>Sink</code> 外观模式多线程安全生产</h4>
<div class="paragraph">
<p>与其直接使用Reactor的 <code>Processors</code>，不如通过 <strong>一次性</strong> 调用 <code>sink()</code> 来获得 <code>Processor</code> 的 <code>Sink</code>。</p>
</div>
<div class="paragraph">
<p><code>FluxProcessor</code> 接收器可以安全地关闭多线程生产者，并可以被多线程并发的生成数据的应用使用。例如，你可以通过以下操作为 <code>UnicastProcessor</code> 创建一个线程安全的序列化接收器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">UnicastProcessor&lt;Integer&gt; processor = UnicastProcessor.create();
FluxSink&lt;Integer&gt; sink = processor.sink(overflowStrategy);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>多个生产者线程可以通过执行以下操作，在下面的序列化接收器上并发的生产数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">sink.next(n);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
尽管 <code>FluxSink</code> 适用于 <code>Processor</code> 的多线程 <strong>手动</strong> 输入，但不可能将订阅者方法和接收器方法混合使用：你必须将 <code>FluxProcessor</code> 订阅到源 <code>Publisher</code> 或者通过它的 <code>FluxSink</code> 手动输入。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从 <code>next</code> 溢出有两种可能的方式，这具体取决于 <code>Processor</code> 及其配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无界处理器通过丢弃或缓冲来处理溢出本身。</p>
</li>
<li>
<p>有界处理器在 <code>IGNORE</code> 策略上阻塞或 &#8220;旋转&#8221;，或为 <code>sink</code> 指定的 <code>overflowStrategy</code> 行为。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="processor-overview"><a class="anchor" href="#processor-overview"></a>4.7.3. 可用处理器概述</h4>
<div class="paragraph">
<p>Reactor核心配备了几种 <code>Processor</code>。并非所有的处理器都有相同的语义，但是它们大致分为三类。以下列表简要介绍了这三类处理器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>直接的</strong> （<code>DirectProcessor</code> 和 <code>UnicastProcessor</code>）：这些处理器只能通过用户直接操作（直接调用其 <code>Sink</code> 方法）来推送数据。</p>
</li>
<li>
<p><strong>同步的</strong>（<code>EmitterProcessor</code> 和 <code>ReplayProcessor</code>）：这些处理器可以通过用户交互推送数据，也可以订阅上游的 <code>Publisher</code> 并同步消耗数据。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
将事件发布到不同线程上的一种方法是将 <code>EmitterProcessor</code> 与 <code>publishOn(Scheduler)</code> 结合使用。例如，这可以取代以前的 <code>TopicProcessor</code>，在3.3.0中，它使用了 <code>Unsafe</code> 操作，并已被移到 <a href="https://github.com/reactor/reactor-addons/tree/master/reactor-extra/src/main/java/reactor/extra/processor">reactor-extra</a>。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_直接的处理器"><a class="anchor" href="#_直接的处理器"></a>直接的处理器</h5>
<div class="paragraph">
<p>直接的 <code>Processor</code> 是一个可以向零个或多个 <code>Subscribers</code> 发送信号的处理器。最简单的实例化，只需要一个 <code>DirectProcessor#create()</code> 静态工厂方法。另一方面，<strong>它具有不处理背压的局限性</strong>。因此，如果你通过 <code>DirectProcessor</code> 推送了N个元素，但是如果有一个订阅者请求数量小于N，那么 <code>DirectProcessor</code> 就会向订阅者发送 <code>IllegalStateException</code> 的信号。</p>
</div>
<div class="paragraph">
<p>一旦 <code>Processor</code> 终止（通常是其接收器的 <code>error(Throwable)</code> 或者 <code>complete()</code> 方法被调用），它就会允许更多的订阅者订阅，但会立即将终止信号传播给它们。</p>
</div>
</div>
<div class="sect4">
<h5 id="_单播处理器"><a class="anchor" href="#_单播处理器"></a>单播处理器</h5>
<div class="paragraph">
<p>单播 <code>Processor</code> 可以通过使用内部缓冲区来处理背压。不足之处是它最多只能有一个 <code>Subscriber</code>。</p>
</div>
<div class="paragraph">
<p>与直接处理器相比，<code>UnicastProcessor</code> 有更多的选项，这一点从几个 <code>create</code> 静态工厂的方法的存在可以反映出来。例如，默认情况下，它是无界的：如果在其 <code>Subscriber</code> 还没有请求数据的时候向它推送任何数量的数据，它将缓冲所有的数据。</p>
</div>
<div class="paragraph">
<p>你可以通过在 <code>create</code> 工厂方法中为内部缓冲区提供一个自定义的 <code>Queue</code> 实现来改变这一点。如果队列是有界的，那么当缓冲区满了，并且没有收到来自下游的足够请求时，处理器可能会拒绝数据的推送。</p>
</div>
<div class="paragraph">
<p>在这种 <em>有界</em> 的情况下，你也可以在处理器上建立一个回调，在每个被拒绝的元素上都会被调用，允许清理这些被拒绝的元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="_发射器处理器"><a class="anchor" href="#_发射器处理器"></a>发射器处理器</h5>
<div class="paragraph">
<p>一个发射器 <code>Processor</code> 可以发射给多个订阅者，同时为其每个订阅者提供背压。它还可以订阅到 <code>Publisher</code> 并同步转发其信号。</p>
</div>
<div class="paragraph">
<p>最开始，在它没有订阅者的时候，它仍然可以接收一些数据推送，最大为可配置的 <code>bufferSize</code>。此后，如果没有 <code>Subscriber</code> 订阅并消费数据，那么就会调用 <code>onNext</code> 块，直到处理器被耗尽为止（这只能同时发生）。</p>
</div>
<div class="paragraph">
<p>因此，第一个 <code>Subscriber</code> 在订阅时，最多接收到 <code>bufferSize</code> 个元素。但是，此后，处理器停止向其它订阅者重播这些信号。这些后续的订阅者只接受到在订阅后通过处理器推送的信号。内部缓冲区仍用于背压。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果它的所有订阅者都被取消了（基本上意味着它们已经全部取消订阅），它将清除其内部缓冲区并停止接收新的订阅者。你可以通过使用 <code>create</code> 静态工厂方法中的 <code>autoCancel</code> 参数来对此进行调整。</p>
</div>
</div>
<div class="sect4">
<h5 id="_重播处理器"><a class="anchor" href="#_重播处理器"></a>重播处理器</h5>
<div class="paragraph">
<p>重播 <code>Processor</code> 缓存了直接通过其 <code>sink()</code> 直接推送或来自上游 <code>Publisher</code> 的元素，并将其重播给后面的订阅者。</p>
</div>
<div class="paragraph">
<p>可以用多种配置来创建它：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>缓存单个元素（<code>cacheLast</code>）。</p>
</li>
<li>
<p>缓存一个有限的历史记录（<code>create(int)</code>）或 无界的历史记录（<code>create()</code>）。</p>
</li>
<li>
<p>缓存基于时间的重播窗口（<code>createTimeout(Duration)</code>）。</p>
</li>
<li>
<p>缓存历史记录大小和时间窗口的组合（<code>createSizeOrTimeout(int, Duration)</code>）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/coreFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#core-features">Reactor核心特性</a>"</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a>5. Kotlin的支持</h2>
<div class="sectionbody">
<div id="kotlin-introduction" class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a> 是一门针对JVM（和其它平台）的静态类型语言，可以编写简洁而优雅的代码，同时与现有的Java扩展库提供了很好的
<a href="https://kotlinlang.org/docs/reference/java-interop.html">互操作性</a>。</p>
</div>
<div class="paragraph">
<p>本节介绍了Reactor对Kotlin的支持。</p>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a>5.1. 要求</h3>
<div class="paragraph">
<p>Reactor支持Kotlin 1.1+，需要 <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib"><code>kotlin-stdlib</code></a>（或 <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre7"><code>kotlin-stdlib-jre7</code></a> 或 <a href="https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jre8"><code>kotlin-stdlib-jre8</code></a> 其中之一）。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a>5.2. 扩展</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从 <code>Dysprosium-M1</code>（即 <code>reactor-core 3.3.0.M1</code>）开始，Kotlin扩展被移到一个专门的 <a href="https://github.com/reactor/reactor-kotlin-extensions"><code>reactor-kotlin-extensions</code></a> 模块，该模块用新的以 <code>reactor.kotlin</code> 开始的包名代替之前简单的 <code>reactor</code>。</p>
</div>
<div class="paragraph">
<p>因此，不推荐使用 <code>reactor-core</code> 模块中的Kotlin扩展。新的依赖项groupId和artifactId是：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">io.projectreactor.kotlin:reactor-kotlin-extensions</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>得益于强大的 <a href="https://kotlinlang.org/docs/reference/java-interop.html">Java互操作性</a>和 <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin扩展</a>，Reactor的Kotlin API使用常规的Java API，并通过对一些Kotlin特有的API进行增强，这些API可以在Reactor中开箱即用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
记住必须要导入Kotlin扩展后才能使用。例如，这意味着只有在导入 <code>import reactor.kotlin.core.publisher.toFlux</code> 的情况下，<code>Throwable.toFlux</code> Kotlin扩展才能使用。也就是说，类似于静态导入，在大多数情况下，IDE应该会自动建议导入。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，
<a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin实化类型参数</a>为JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">泛型类型擦除</a>提供了一个解决方案，且Reactor提供了一些扩展来利用这个特性。</p>
</div>
<div class="paragraph">
<p>下表比较了Java中的Reactor和Kotlin中的Reactor扩展。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Java</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Kotlin扩展</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.just("foo")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"foo".toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.fromIterable(list)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>list.toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType(Foo.class)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType&lt;Foo&gt;()</code> 或 <code>flux.ofType(Foo::class)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StepVerifier.create(flux).verifyComplete()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.test().verifyComplete()</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="https://projectreactor.io/docs/kotlin/release/kdoc-api/">Reactor KDoc API</a>列出并记录了所有可用的Kotlin扩展。</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a>5.3. 空安全</h3>
<div class="paragraph">
<p>Kotlin的关键特性之一是 <a href="https://kotlinlang.org/docs/reference/null-safety.html">空安全</a>，它在编译时干净利落地处理了 <code>null</code> 值，而不是在运行时碰到著名的 <code>NullPointerException</code> 异常。通过可空性的声明和 &#8220;有值或者无值&#8221; 的语义表达可以使应用更加安全，而不需要花费代价进行诸如 <code>Optional</code> 这样的封装。（Kotlin允许使用具有空值的函数构造。请看 <a href="https://www.baeldung.com/kotlin-null-safety">关于Kotlin空安全的全面指南</a>。）</p>
</div>
<div class="paragraph">
<p>尽管Java不允许在其类型系统中表示null安全，但通过在 <code>reactor.util.annotation</code> 包中声明的友好的注释，Reactor为整个Reactor API<a href="#null-safety">提供空安全</a>。默认情况下，Kotlin中使用的Java API中的类型会被识别为 <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">平台类型</a>，对于这些类型，空检查可以放宽。
<a href="https://github.com/Kotlin/KEEP/blob/jsr-305/proposals/jsr-305-custom-nullability-qualifiers.md">Kotlin支持JSR 305注释</a> 和Reactor可空性注释为Kotlin开发者提供了整个Reactor API的空安全，在编译时处理 <code>null</code> 相关问题的优势。</p>
</div>
<div class="paragraph">
<p>你可以通过添加 <code>-Xjsr305</code> 编译器标签来配置JSR 305的检查，并使用以下选项：<code>-Xjsr305={strict|warn|ignore}</code>。</p>
</div>
<div class="paragraph">
<p>对于Kotlin 1.1.50+的版本，默认行为与 <code>-Xjsr305=warn</code> 相同。<code>strict</code> 表示需要考虑Reactor API的完全空安全，但应该被认为是实验性的，因为Reactor API的可空性声明即使是在小的发行版之间也会发生演变，也可能会在未来增加更多的检查。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
尚不支持泛型类型参数和变量参数，数组元素的可空性，但是应该会在即将发布的版本中出现。有关最新的信息，请看 <a href="https://github.com/Kotlin/KEEP/issues/79">此讨论</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/kotlin.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#kotlin">Kotlin的支持</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>6. 测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>无论你是写了一个简单的Reactor操作符链还是自己的操作符，自动化测试都是一个不错的选择。</p>
</div>
<div class="paragraph">
<p>Reactor自带了一些专门用于测试的元素，汇总到自己的artifact：<code>reactor-test</code>。在 <code>reactor-core</code> 仓库中，你能够 <a href="https://github.com/reactor/reactor-core/tree/master/reactor-test/src">在Github</a> 找到该项目。</p>
</div>
<div class="paragraph">
<p>要在测试中使用它，你必须将其添加作为测试依赖。下面的例子显示了如何在Maven中怎么添加 <code>reactor-test</code> 作为依赖：</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Maven中的reactor-test, 在 <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用了 <a href="#getting">BOM</a>，你不需要指定 <code>&lt;version&gt;</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子显示了如何在Gradle中添加 <code>reactor-test</code> 作为依赖：</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. Gradle中的reactor-test, 修改 <code>dependencies</code> 块</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
   testCompile 'io.projectreactor:reactor-test'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>reactor-test</code> 的三个主要用途如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用 <code>StepVerifier</code> 逐步测试一个序列是否遵循给定的场景。</p>
</li>
<li>
<p>生产数据，以便用 <code>TestPublisher</code> 测试下游操作符（包括你自己的操作符）的行为。</p>
</li>
<li>
<p>在可以经过多个可选择的 <code>Publisher</code> 的序列(例如，一个使用 <code>switchIfEmpty</code> 的链，进行 <code>Publisher</code> 的探测，以确保它已被使用（即已订阅）) 中。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_使用_stepverifier_测试一个场景"><a class="anchor" href="#_使用_stepverifier_测试一个场景"></a>6.1. 使用 <code>StepVerifier</code> 测试一个场景</h3>
<div class="paragraph">
<p>测试Reactor序列最常见的情况是在你代码中定义了一个 <code>Flux</code> 或者 <code>Mono</code>（例如，可能是由一个方法返回的），想要测试它在订阅时的行为。</p>
</div>
<div class="paragraph">
<p>这种情况可以很好地转化为定义一个 &#8220;测试场景&#8221;，可以根据事件，一步步定义你的期望。你可能会问到并回答诸如下面的问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>下一个预期的事件是什么？</p>
</li>
<li>
<p>你希望 <code>Flux</code> 发射出一个特定的值？</p>
</li>
<li>
<p>或者在接下来的300ms内什么都不做？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以通过 <code>StepVerifier</code> API来表达这一切。</p>
</div>
<div class="paragraph">
<p>例如，你可以在你的代码库中使用下面的工具方法来装饰一个 <code>Flux</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public &lt;T&gt; Flux&lt;T&gt; appendBoomError(Flux&lt;T&gt; source) {
  return source.concatWith(Mono.error(new IllegalArgumentException("boom")));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了测试它，你要验证以下场景：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我希望这个 <code>Flux</code> 首先产生 <code>thing1</code>，然后产生 <code>thing2</code>，接着 <strong>产生带有错误消息</strong> 的 <code>boom</code>。订阅并 <strong>验证</strong> 这些期望。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>在 <code>StepVerifier</code> API中，这可以转化为以下测试：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testAppendBoomError() {
  Flux&lt;String&gt; source = Flux.just("thing1", "thing2"); <i class="conum" data-value="1"></i><b>(1)</b>

  StepVerifier.create( <i class="conum" data-value="2"></i><b>(2)</b>
    appendBoomError(source)) <i class="conum" data-value="3"></i><b>(3)</b>
    .expectNext("thing1") <i class="conum" data-value="4"></i><b>(4)</b>
    .expectNext("thing2")
    .expectErrorMessage("boom") <i class="conum" data-value="5"></i><b>(5)</b>
    .verify(); <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>因为我们的方法需要一个源 <code>Flux</code>，所以定义一个简单的源来作为测试。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个 <code>StepVerifier</code> 构建器，用于封装和验证 <code>Flux</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>传递要测试的 <code>Flux</code>（调用我们工具方法的结果）。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们期望在订阅时产生的第一个信号是 <code>onNext</code>，值为 <code>thing1</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>我们期望的最后一个信号是以 <code>onError</code> 终止序列。这个异常应该包含 <code>boom</code> 信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>重要的是通过调用 <code>verify()</code> 触发测试。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>这个API是一个构建器。你首先创建 <code>StepVerifier</code> 并传递要测试的序列。这提供了一种方法选择，可以让你：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表达对下一个信号发生的期望。如果收到任何其他信号（或者信号的内容与预期不符），整个测试都会以一个有意义的 <code>AssertionError</code> 失败。例如，你可以使用 <code>expectNext(T&#8230;&#8203;)</code> 和 <code>expectNextCount(long)</code>。</p>
</li>
<li>
<p>消费下一个信号。当你想要略过序列的一部分，或者想对信号的内容应用一个自定义的 <code>assertion</code>（例如，为了检测是否存在 <code>onNext</code> 事件并断言产生的列表元素个数大小为5），例如，你可以使用 <code>consumeNextWith(Consumer&lt;T&gt;)</code>。</p>
</li>
<li>
<p>执行诸如暂停或运行任意代码等其他操作。例如，如果你想要操纵一个特定的测试状态或上下文。为此，你可以使用 <code>thenAwait(Duration)</code> 和 <code>then(Runnable)</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于终止事件，相应的期望方法（<code>expectComplete()</code> 和 <code>expectError()</code> 及其其它的形式）会切换到一个你无法再表达期望的API中。在这最后一步，你能做的就是再 <code>StepVerifier</code> 上执行一些额外的配置，然后触发验证，通常是用 <code>verify()</code> 或其其它形式之一。</p>
</div>
<div class="paragraph">
<p>此时， <code>StepVerifier</code> 订阅了被测试的 <code>Flux</code> 或 <code>Mono</code>，并触发序列的开始，将每一个新信号与场景中的下一个步骤进行比较。只要这些符合，测试就视为成功。一旦有一个差异，将会抛出 <code>AssertionError</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
记住 <code>verify()</code> 步骤，它触发了验证。为了提供帮助，API包含了一些快捷方法，将终止期望与调用 <code>verify()</code> 结合起来： <code>verifyComplete()</code>，<code>verifyError()</code>，<code>verifyErrorMessage(String)</code> 等。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>注意，如果其中一个基于lambda的期望抛出一个 <code>AssertionError</code>，则会按原样报告，测试失败。这对于自定义断言是很有用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
默认情况下，<code>verify()</code> 方法和派生的快捷方法（<code>verifyThenAssertThat</code>，<code>verifyComplete()</code> 等）没有超时时间。它们可以无限制地阻塞。你可以使用 <code>StepVerifier.setDefaultTimeout(Duration)</code> 为这些方法全局设置一个超时时间，或者用 <code>verify(Duration)</code> 指定一个超时。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_更好地识别测试失败"><a class="anchor" href="#_更好地识别测试失败"></a>6.1.1. 更好地识别测试失败</h4>
<div class="paragraph">
<p><code>StepVerifier</code> 提供了两个选项，以更好地确定是哪个期望步骤导致测试失败：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>as(String)</code>：用在大多数 <code>expect*</code> 方法之后，用于给出先前期望的描述。如果期望失败，其错误信息会包含该描述。终止期望和 <code>verify</code> 不能使用该方式进行描述。</p>
</li>
<li>
<p><code>StepVerifierOptions.create().scenarioName(String)</code>：通过使用 <code>StepVerifierOptions</code> 来创建你的 <code>StepVerifier</code>，你可以使用 <code>scenarioName</code> 方法为整个场景命名，这个名字也可用于在断言错误信息中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>注意，在两种情况下，只能保证在使用 <code>StepVerifier</code> 它们自己的方法产生的 <code>AssertionError</code> 信息中使用描述和名称（例如，手动抛出一个异常或通过 <code>assertNext</code> 中的断言库，则不会将描述或名称添加到错误消息中）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操纵时间"><a class="anchor" href="#_操纵时间"></a>6.2. 操纵时间</h3>
<div class="paragraph">
<p>你可以使用基于时间的操作符的 <code>StepVerifier</code> 来避免相应的测试长时间的运行。你可以通过 <code>StepVerifier.withVirtualTime</code> 构建器来实现。</p>
</div>
<div class="paragraph">
<p>它看起来像下面这个例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
//... 这里继续期望</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个虚拟时间的功能在Reactor的 <code>Schedulers</code> 工厂中插入一个自定义的 <code>Scheduler</code>。由于这些时间操作符通常使用默认的 <code>Schedulers.parallel()</code> 调度器，所以用 <code>VirtualTimeScheduler</code> 代替它就行了。但是，一个重要的前提是，这个操作符必须在虚拟时间调度器被激活后实例化。</p>
</div>
<div class="paragraph">
<p>为了增加这种情况正确发生的几率，<code>StepVerifier</code> 不接受简单的 <code>Flux</code> 作为输入。<code>withVirtualTime</code> 需要一个 <code>Supplier</code>，在完成调度器的设置后，它会缓慢地引导你创建被测试的Flux的实例。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
请格外小心，确保在懒加载下 <code>Supplier&lt;Publisher&lt;T&gt;&gt;</code> 能被使用。否则，虚拟时间无法被保证。特别是避免在测试代码中 <code>Flux</code> 的过早实例化和并让 <code>Supplier</code> 返回该变量。相反，总是在lambda中实例化 <code>Flux</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>处理时间的期望方法有两种，不管有没有虚拟时间，都是有效的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thenAwait(Duration)</code>：暂停步骤的计算（允许一些信号发生或延迟耗尽）。</p>
</li>
<li>
<p><code>expectNoEvent(Duration)</code>：也可以让序列在给定的持续时间内产生元素，但是如果在这段时间内有 <em>其它</em> 信号产生，则测试失败。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在经典模式下，这两种方法都会暂停线程的给定时间，而在虚拟模式下，则会提前虚拟时钟。</p>
</div>
<div id="tip-expectNoEvent" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>expectNoEvent</code> 也将 <code>subscription</code> 视为一个事件。如果你把它作为第一步使用，通常会失败，因为会检测到订阅信号。用 <code>expectSubscription().expectNoEvent(duration)</code> 代替它。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了快速计算我们上面的 <code>Mono.delay</code> 的行为，可以通过以下方式完成代码的编写：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
    .expectSubscription() <i class="conum" data-value="1"></i><b>(1)</b>
    .expectNoEvent(Duration.ofDays(1)) <i class="conum" data-value="2"></i><b>(2)</b>
    .expectNext(0L) <i class="conum" data-value="3"></i><b>(3)</b>
    .verifyComplete(); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>见前面的 <a href="#tip-expectNoEvent">tip</a>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>期待一整天都不会有什么事情发生。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后期待发射数据是 <code>0</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>然后期待完成（并触发验证）。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以使用上面的 <code>thenAwait(Duration.ofDays(1))</code>，但 <code>expectNoEvent</code> 能够确保什么都不会过早发生。</p>
</div>
<div class="paragraph">
<p>注意，<code>verify()</code> 返回一个 <code>Duration</code>。这是整个测试的实时持续时间。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
虚拟时间不是银弹。所有的 <code>Schedulers</code> 都是被替换为相同的 <code>VirtualTimeScheduler</code>。在某些情况下，你可以锁定验证过程，因为在期望表达前，虚拟时钟并未开始计时，从而导致在期望等待的数据只能提前产生。在大多数情况下，你需要将虚拟时钟提前，才能发出序列。无限序列的虚拟时间也会受到限制，这可能会占用序列和检测运行所在的线程。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_用_stepverifier_执行执行后断言"><a class="anchor" href="#_用_stepverifier_执行执行后断言"></a>6.3. 用 <code>StepVerifier</code> 执行执行后断言</h3>
<div class="paragraph">
<p>在描述了你的场景中的最终期望后，你可以切换到一个补充的断言API，而不是触发 <code>verify()</code>。为此，你需要使用 <code>verifyThenAssertThat()</code>。</p>
</div>
<div class="paragraph">
<p><code>verifyThenAssertThat()</code> 返回一个 <code>StepVerifier.Assertions</code> 对象，一旦整个场景成功地执行了，你可以使用它来断言一些状态元素（因为它同样会调用 <code>verify()</code>）。典型（即高级）的用法是捕获被某些操作符丢弃的元素并断言它们（参见<a href="#hooks">钩子</a>章节）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试_上下文"><a class="anchor" href="#_测试_上下文"></a>6.4. 测试 <code>上下文</code></h3>
<div class="paragraph">
<p>关于 <code>上下文</code> 的更多信息，请看<a href="#context">为响应式序列添加上下文</a>。</p>
</div>
<div class="paragraph">
<p>在 <code>Context</code> 的传播过程中，<code>StepVerifier</code> 附带一些期望：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectAccessibleContext</code>：返回一个 <code>ContextExpectations</code> 对象，你可以使用这个对象来设置在传播 <code>Context</code> 的期望。确保调用 <code>then()</code> 能够返回到序列期望集。</p>
</li>
<li>
<p><code>expectNoAccessibleContext</code>：设置了一个期望，使其在被测试的操作符链上不能传播任何 <code>Context</code>。这最有可能发生在当测试的不是响应式的 <code>Publisher</code> 或没有任何可以传播 <code>Context</code>（例如，生成器源）的操作符</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，你可以通过使用 <code>StepVerifierOptions</code> 来创建验证器，将特定于测试的初始 <code>Context</code> 关联到 <code>StepVerifier</code>。</p>
</div>
<div class="paragraph">
<p>下面的片段展示了这些特性：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(Mono.just(1).map(i -&gt; i + 10),
				StepVerifierOptions.create().withInitialContext(Context.of("thing1", "thing2"))) <i class="conum" data-value="1"></i><b>(1)</b>
		            .expectAccessibleContext() <i class="conum" data-value="2"></i><b>(2)</b>
		            .contains("foo", "bar") <i class="conum" data-value="3"></i><b>(3)</b>
		            .then() <i class="conum" data-value="4"></i><b>(4)</b>
		            .expectNext(11)
		            .verifyComplete(); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通过使用 <code>StepVerifierOptions</code> 创建 <code>StepVerifier</code> 并传递一个初始化的 <code>Context</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>开始设置关于 <code>Context</code> 传播的期望。仅此一项就可以确保 <code>Context</code> 的传播。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>特定 <code>Context</code> 期望的一个例子。它必须包含键 "thing1" 的值 "thing2"。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们使用 <code>then()</code> 切换回对数据设置正常对期望。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>让我们不要忘记对整个期望集合进行 <code>verify()</code>。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_用_testpublisher_手动发射"><a class="anchor" href="#_用_testpublisher_手动发射"></a>6.5. 用 <code>TestPublisher</code> 手动发射</h3>
<div class="paragraph">
<p>对于更高级的测试用例来说，完全掌握数据源，能够触发精心选择的信号，使之与你要测试的特定情况紧密匹配会更有用。</p>
</div>
<div class="paragraph">
<p>另一种情况是当你已经实现了自己的操作符，想要验证其在关于响应式流规范的行为，特别是其源不能够很好表现时。</p>
</div>
<div class="paragraph">
<p>对于这两种情况，<code>reactor-test</code> 提供了 <code>TestPublisher</code> 类。这是一个能让你以编程方式触发各种信号的 <code>Publisher&lt;T&gt;</code>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next(T)</code> 和 <code>next(T, T&#8230;&#8203;)</code> 触发1到n个 <code>onNext</code> 信号。</p>
</li>
<li>
<p><code>emit(T&#8230;&#8203;)</code> 触发1到n个 <code>onNext</code> 信号并执行 <code>complete()</code>。</p>
</li>
<li>
<p><code>complete()</code> 以 <code>onComplete</code> 信号终止。</p>
</li>
<li>
<p><code>error(Throwable)</code> 以 <code>onError</code> 信号终止。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以通过 <code>create</code> 工厂方法获得一个表现良好的 <code>TestPublisher</code>。另外，你也可以通过使用 <code>createNonCompliant</code> 工厂方法创建一个表现不好的 <code>TestPublisher</code>。后者从 <code>TestPublisher.Violation</code> 枚举中取一个或多个值。这些值定义了生产者可以忽略规范中的哪些部分。这些枚举值包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REQUEST_OVERFLOW</code>：允许在请求不足的情况下进行 <code>next</code> 调用，且不会触发 <code>IllegalStateException</code>。</p>
</li>
<li>
<p><code>ALLOW_NULL</code>：允许 <code>null</code> 值进行 <code>next</code> 调用而不会触发 <code>NullPointerException</code> 异常。</p>
</li>
<li>
<p><code>CLEANUP_ON_TERMINATE</code>：允许连续多次发送终止信号。这包括 <code>complete()</code>、<code>error()</code> 和 <code>emit()</code>。</p>
</li>
<li>
<p><code>DEFER_CANCELLATION</code>：允许 <code>TestPublisher</code> 忽略取消信号并继续发送信号，就好像取消信号输掉了与所讲信号的比赛一样。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，<code>TestPublisher</code> 保持着订阅后的内部状态，可以通过它的各种 <code>assert*</code> 方法进行断言。</p>
</div>
<div class="paragraph">
<p>你可以使用转换方法 <code>flux()</code> 和 <code>mono()</code>，将其转换为 <code>Flux</code> 或 <code>Mono</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用_publisherprobe_检查执行路径"><a class="anchor" href="#_用_publisherprobe_检查执行路径"></a>6.6. 用 <code>PublisherProbe</code> 检查执行路径</h3>
<div class="paragraph">
<p>在构造复杂的操作符链时，你可能会遇到有几个可能的执行途经，由不同的子序列具体化的情况。</p>
</div>
<div class="paragraph">
<p>大多数时候，这些子序列会产生一个特定的 <code>onNext</code> 信号，能够通过查看最终结果来断言其已执行。</p>
</div>
<div class="paragraph">
<p>例如，考虑下面的方法，它从源构建一个操作符链，如果源为空，则使用 <code>switchIfEmpty</code> 来回退到一个特定替代的源：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Flux&lt;String&gt; processOrFallback(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback) {
    return source
            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split("\\s+")))
            .switchIfEmpty(fallback);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以测试使用了switchIfEmpty的哪个逻辑分支，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testSplitPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.just("just a  phrase with    tabs!"),
            Mono.just("EMPTY_PHRASE")))
                .expectNext("just", "a", "phrase", "with", "tabs!")
                .verifyComplete();
}

@Test
public void testEmptyPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just("EMPTY_PHRASE")))
                .expectNext("EMPTY_PHRASE")
                .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是，想想看一个例子，该方法产生一个 <code>Mono&lt;Void&gt;</code>。它等待源完成，执行一个额外的任务并完成。如果源为空，必须执行类似于 <code>Runnable</code> 的降级任务。下面的例子显示了这种情况：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Mono&lt;String&gt; executeCommand(String command) {
    return Mono.just(command + " DONE");
}

public Mono&lt;Void&gt; processOrFallback(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty) {
    return commandSource
            .flatMap(command -&gt; executeCommand(command).then()) <i class="conum" data-value="1"></i><b>(1)</b>
            .switchIfEmpty(doWhenEmpty); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>then()</code> 忽略命令执行结果。它只关心它是否完成了。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如何区分两个都是空序列的情况？</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>为了验证你的 <code>processOrFallback</code> 方法确实执行了 <code>doWhenEmpty</code> 分支，你需要写一些样板。即你需要一个 <code>Mono&lt;Void&gt;</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>捕获已经订阅的事实。</p>
</li>
<li>
<p>让你在整个过程结束 <em>后</em> 断言该事实。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在3.1版本之前，你需要为每个你想要断言的状态手动维护一个 <code>AtomicBoolean</code>，并将相应的 <code>doOn*</code> 回调附加到你需要评估的生产者上。当需要经常使用该模式时，这可能会有很多繁琐的模版。幸运的是，3.1.0引入了 <code>PublisherProbe</code> 的替代方案。下面的例子展示了如何使用它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void testCommandEmptyPathIsUsed() {
    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <i class="conum" data-value="2"></i><b>(2)</b>
                .verifyComplete();

    probe.assertWasSubscribed(); <i class="conum" data-value="3"></i><b>(3)</b>
    probe.assertWasRequested(); <i class="conum" data-value="4"></i><b>(4)</b>
    probe.assertWasNotCancelled(); <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个转换为空序列的探针。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>通过调用 <code>probe.mono()</code> 让探针代替 <code>Mono&lt;Void&gt;</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>序列完成后，探针可断言它已被使用。你能检测它是否已被订阅&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;以及实际请求的数据&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;以及是否被取消。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以通过调用 <code>.flux()</code> 替换 <code>.mono()</code>，及让探针代替 <code>Flux&lt;T&gt;</code>。对于你想要探针执行途经并也需要探针发射数据的情况，你可以使用 <code>PublisherProbe.of(Publisher)</code> 来封装任何 <code>Publisher&lt;T&gt;</code>。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/testing.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#testing">测试</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging"><a class="anchor" href="#debugging"></a>7. 调试Reactor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从命令式同步编程范式切换到响应式异步范式编程有时会让人望而生畏。学习曲线中最陡峭的步骤之一，就是在出现问题时如何分析和调试。</p>
</div>
<div class="paragraph">
<p>在命令式编程中，调试通常是相当直接的。你可以阅读堆栈跟踪，查看问题的根源。完全是代码出现了故障？该故障是否发生在其它库的代码中？如果是这样，代码的哪一部分是调用了库，可能是传入了不正确的参数，从而导致故障？</p>
</div>
<div class="sect2">
<h3 id="_典型的响应式堆栈追踪"><a class="anchor" href="#_典型的响应式堆栈追踪"></a>7.1. 典型的响应式堆栈追踪</h3>
<div class="paragraph">
<p>当你转向异步代码时，事情会变得更加复杂。</p>
</div>
<div class="paragraph">
<p>考虑一下下面的堆栈信息：</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. 典型的Reactor堆栈追踪</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">java.lang.IndexOutOfBoundsException: Source emitted more than one item
	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:445)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:379)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)
	at reactor.core.publisher.FluxRange$RangeSubscription.slowPath(FluxRange.java:154)
	at reactor.core.publisher.FluxRange$RangeSubscription.request(FluxRange.java:109)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:332)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)
	at reactor.core.publisher.FluxRange.subscribe(FluxRange.java:68)
	at reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)
	at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97)
	at reactor.core.publisher.MonoSingle.subscribe(MonoSingle.java:58)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3096)
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
	at reactor.guide.GuideTests.debuggingCommonStacktrace(GuideTests.java:995)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里面有很多事情。我们得到一个 <code>IndexOutOfBoundsException</code> 异常，这告诉我们 <code>源发射了超过一个以上的元素</code>。</p>
</div>
<div class="paragraph">
<p>从下一行提到的 <code>MonoSingle</code>，我们可能很快就能推断出该源为一个Flux或者Mono。因此，这似乎是从一个 <code>single</code> 操作符报的错误。</p>
</div>
<div class="paragraph">
<p>参照 <code>Mono#single</code> 操作符的Javadoc，我们可以看到 <code>single</code> 有一个约定：源必须精确地发射一个元素。看来我们有一个源发射了超过一个以上的元素，因此违反了这一约定。</p>
</div>
<div class="paragraph">
<p>我们可以更深入地挖掘并确定那个源？下面这几行，对我们的帮助不大。它们通过多次调用 <code>subscribe</code> 和 <code>request</code>， 带我们了解了似乎是一个响应式链的内部。</p>
</div>
<div class="paragraph">
<p>通过略读这些行，我们至少可以开始形成一个出错的链的脑图：它似乎涉及到 <code>MonoSingle</code> 和 <code>FluxFlatMap</code>，<code>FluxRange</code>（每个在堆栈跟踪中都能获得几行，但总体上这三个类都涉及到了）。所以也许是一个 <code>range().flatMap().single()</code> 链？</p>
</div>
<div class="paragraph">
<p>但是如果我们在应用中大量使用该模式？这仍然不能说明什么问题，单纯的搜索 <code>single</code> 并不能发现问题。然后，最后一行值的是我们自己的一些代码。最终，我们离真相越来越近的。</p>
</div>
<div class="paragraph">
<p>不过，等一下。当我们跳到源文件时，我们只看到一个预先存在到 <code>Flux</code> 被订阅，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">toDebug.subscribe(System.out::println, Throwable::printStackTrace);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所有这些都是在订阅时发生的，但是 <code>Flux</code> 本身并没有在那里声明。更糟糕的是，当我们转到声明变量的地方时时，我们会看到下面的内容：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Mono&lt;String&gt; toDebug; //请忽略公共类属性</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>变量没有在它被声明的地方被实例化。我们必须假设一个最坏的情况，即我们发现可能有几个不同的代码路径在应用程序中设置它。我们仍然不确定是哪一个引起的问题。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这有点类似于Reactor的运行时错误，而不是编译错误。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们想更容易发现的是操作符添加到链的位置，即 <code>Flux</code> 声明的地方。我们通常将其称为 <code>Flux</code> 的 &#8220;装配&#8221;。</p>
</div>
</div>
<div class="sect2">
<h3 id="debug-activate"><a class="anchor" href="#debug-activate"></a>7.2. 激活调试模式 - 又名回溯</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
本节描述了最简单但也是最慢的方式来启用调试能力，因为它捕获每个操作符上的堆栈。了解更详细的调试方式，请看<a href="#checkpoint-alternative"><code>checkpoint()</code> 替代方案</a>，以及对于更高级性能的全局选项，请看<a href="#reactor-tools-debug">可生产的全局调试</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>尽管对于稍微有点经验的来说，堆栈跟踪能为还是能够表达一些信息，但是我们可以看出，在更高级的案例中，单凭它本身的效果并不理想。</p>
</div>
<div class="paragraph">
<p>幸运的是，Reactor自带了专门用于调试设计的装配时设施。</p>
</div>
<div class="paragraph">
<p>这可以通过在应用启动时（或至少在所怀疑的 <code>Flux</code> 或者 <code>Mono</code> 实例化前）自定义 <code>Hooks.onOperator</code> 钩子来实现，如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Hooks.onOperatorDebug();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过在这里包装操作符的构造和捕获堆栈跟踪开始对 <code>Flux</code>（和 <code>Mono</code>）操作符方法（装配到链的）的调用进行检测。因为这是在声明操作符链时完成的，所以钩子应该在这之前被激活，所以最安全的方式是直接在应用开始时就激活它。</p>
</div>
<div class="paragraph">
<p>之后，如果发生异常，失败的操作符能够引用该捕获的信息并将其附加到堆栈跟踪中。我们将捕获的装配信息称为 <strong>回溯</strong>。</p>
</div>
<div class="paragraph">
<p>在下一节中，我们将看到堆栈跟踪有什么不同，以及如何解释这些新的信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在调试模式下读取堆栈跟踪"><a class="anchor" href="#_在调试模式下读取堆栈跟踪"></a>7.3. 在调试模式下读取堆栈跟踪</h3>
<div class="paragraph">
<p>当我们再次使用最开始的例子，但在激活 <code>operatorStacktrace</code> 调试功能的时候，堆栈追踪如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">java.lang.IndexOutOfBoundsException: Source emitted more than one item
	at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:375) <i class="conum" data-value="1"></i><b>(1)</b>
...
<i class="conum" data-value="2"></i><b>(2)</b>
...
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
	at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
	at reactor.guide.GuideTests.debuggingActivated(GuideTests.java:1000)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <i class="conum" data-value="3"></i><b>(3)</b>
Assembly trace from producer [reactor.core.publisher.MonoSingle] : <i class="conum" data-value="4"></i><b>(4)</b>
	reactor.core.publisher.Flux.single(Flux.java:6676)
	reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949)
	reactor.guide.GuideTests.populateDebug(GuideTests.java:962)
	org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	org.junit.rules.RunRules.evaluate(RunRules.java:20)
Error has been observed by the following operator(s): <i class="conum" data-value="5"></i><b>(5)</b>
	|_	Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949) <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这是新的异常信息：我们可以看到捕获堆栈的包装操作符。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>除此之外，第一部分的堆栈依然几乎相同，显示了一些操作符（所以我们在这里去掉了一些代码片段）内部。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>这就是回溯开始出现的地方。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>首先，我们得到一些装配操作符处的详细信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>当错误通过操作符链传播时，我们还可以从头到尾（错误端到订阅端）追溯到该错误。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>每个看到错误的操作符都会提到使用的用户类和行。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>捕获的堆栈跟踪会作为简约的 <code>OnAssemblyException</code> 异常附加到原始错误中。它分为两部分，但第一部分是最有趣的。它显示了触发异常的操作符的构造路径。在这里，它显示了是 <code>scatterAndGather</code> 方法中创建的 <code>single</code> 导致了问题，它本身是通过JUnit执行的 <code>populateDebug</code> 方法调用的。</p>
</div>
<div class="paragraph">
<p>现在我们已经掌握了足够的信息来找到罪魁祸首，我们对 <code>scatterAndGather</code> 方法进行有意义的研究：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Mono&lt;String&gt; scatterAndGather(Flux&lt;String&gt; urls) {
    return urls.flatMap(url -&gt; doRequest(url))
           .single(); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>果然，这里是 <code>single</code> 方法。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们可以看到导致错误的根本原因是 <code>flatMap</code> 对几个url执行了几个HTTP调用，但是这个调用是用 <code>single</code> 串联起来的，限制性太强了。经过简短的使用 <code>git blame</code>，并与该行代码的作者进行了简短的讨论后，我们发现他打算使用限制性较小的 <code>take(1)</code> 来代替。</p>
</div>
<div class="paragraph">
<p>我们的问题已经解决了。</p>
</div>
<div class="paragraph">
<p>现在看下在堆栈跟踪中的这一行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Error has been observed by the following operator(s):</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个特殊的例子中，调试堆栈跟踪的第二部分并不一定有意思，因为错误实际上发生在链中的最后一个操作符（最接近 <code>订阅</code> 的那个）。考虑另一个例子可能会更清晰：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">FakeRepository.findAllUserByName(Flux.just("pedro", "simon", "stephane"))
              .transform(FakeUtils1.applyFilters)
              .transform(FakeUtils2.enrichUser)
              .blockLast();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在想象一下，在 <code>findAllUserByName</code> 中，有一个 <code>map</code> 失败了。在这里，我们将看到下面的的回溯：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Error has been observed by the following operator(s):
	|_	Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)
	|_	Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)
	|_	Flux.filter ⇢ reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)
	|_	Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)
	|_	Flux.elapsed ⇢ reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)
	|_	Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这对应的是操作符链中被通知错误的那部分：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>异常源于第一个 <code>map</code>。</p>
</li>
<li>
<p>它被第二个 <code>map</code> 看到了（实际上这两个方法都对应于 <code>findAllUserByName</code> 方法）。</p>
</li>
<li>
<p>然后通过一个 <code>filter</code> 和 <code>transform</code> 看到它，这表示链的那部分是由可重用的转换函数构成（这里是 <code>applyFilters</code> 工具方法）的。</p>
</li>
<li>
<p>最后，通过一个 <code>elapsed</code> 和 <code>transform</code> 看到它。<code>elapsed</code> 是由第二个转换的转换函数所使用。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
当回溯作为简短的异常被附加到原始错误中，这可能在某种程度上会干扰另一种使用此机制的另一种异常：复合异常。这类异常可以直接通过 <code>Exceptions.multiple(Throwable&#8230;&#8203;)</code> 来创建，或者通过一些可能连接多个错误源（如 <code>Flux#flatMapDelayError</code>）的操作符来创建。它们可以通过 <code>Exceptions.unwrapMultiple(Throwable)</code> 展开到 <code>List</code> 中，在这种情况下，回溯会被视为组合的一个组件，并成为返回的 <code>List</code> 的一部分。相反，如果不需要的话，可以通过 <code>Exceptions.isTraceback(Throwable)</code> 检查来标识回溯，并使用 <code>Exceptions.unwrapMultipleExcludingTracebacks(Throwable)</code> 将其排除在展开之外。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们在这里以检测的形式处理，而创建堆栈追踪的代价是非常高的。这就是为什么这个调试功能只应该以可把控的方式激活，并只能当作最后的办法。</p>
</div>
<div class="sect3">
<h4 id="checkpoint-alternative"><a class="anchor" href="#checkpoint-alternative"></a>7.3.1. <code>checkpoint()</code> 替代方案</h4>
<div class="paragraph">
<p>调试模式是全局的，它影响到应用程序中的每一个操作符，并将其组装到 <code>Flux</code> 或 <code>Mono</code> 中。这样做的好处是允许事后调试：无论是什么错误，我们都可以获取更多的信息来调试。</p>
</div>
<div class="paragraph">
<p>正如我们前面看到的，这种全局的能力是以牺牲性能（由于填充的堆栈跟踪的数量）为代价的。如果我们知道可能是某个操作符有问题，那么这个代价可以降低。但是，我们通常不知道哪个操作符出现了问题，除非我们明显地看到错误，看到自己丢失了组装信息，然后修改代码激活组装追踪，希望再次观察到相同的错误。</p>
</div>
<div class="paragraph">
<p>在那种场景下，我们必须切换到调试模式，并做好准备以便更好地观察到第二次出现的错误，这一次捕获到所有额外的信息。</p>
</div>
<div class="paragraph">
<p>如果你能识别出你在应用中组装的，且对其可用性至关重要的响应式链。那么你可以使用 <code>checkpoint()</code> 操作符将两种技术结合。</p>
</div>
<div class="paragraph">
<p>你可以将此操作符链接到方法链中。<code>checkpoint</code> 操作符的工作原理与像钩子版本一样，但仅适用于特定链的链接。</p>
</div>
<div class="paragraph">
<p>这里还有 <code>checkpoint(String)</code> 的另一种形式，能让你添加唯一的 <code>String</code> 标识符到组合的回溯。这样，就省略了堆栈追踪，并依靠描述来识别装配的位置。<code>checkpoint(String)</code> 较于普通的 <code>checkpoint</code> 代价要低。</p>
</div>
<div class="paragraph">
<p><code>checkpoint(String)</code> 在其输出中（这搜索时会非常方便）包含了 &#8220;light&#8221; ，如下面例子所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">...
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:
Assembly site of producer [reactor.core.publisher.ParallelSource] is identified by light checkpoint [light checkpoint identifier].</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后但并非最不重要的，如果你想要添加更通用的描述到检测点，但仍然依靠堆栈跟踪机制来识别装配的位置，你可以通过使用 <code>checkpoint("description", true)</code> 来强制执行该行为。我们现在又回到了回溯的初始信息，并添加了 <code>description</code>，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] : <i class="conum" data-value="1"></i><b>(1)</b>
	reactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:215)
	reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)
Error has been observed by the following operator(s):
	|_	ParallelFlux.checkpoint ⇢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>descriptionCorrelation1234</code> 是 <code>checkpont</code> 中提供的描述。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>该描述可以是一个静态的标识符或用户可读的描述，也可以是更广泛的相关ID（例如，在HTTP请求的情况下，来自于一个请求头的）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当全局调试和本地 <code>checkpoint()</code> 都启用时，检测点的快照堆栈作为简短的错误输出附加到观察操作符图之后，并遵循相同的声明性顺序。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor-tools-debug"><a class="anchor" href="#reactor-tools-debug"></a>7.4. 可生产的全局调试</h3>
<div class="paragraph">
<p>Reactor工程自带了一个独立的Java代理，可以增强你的代码并添加调试信息，而不需要花费捕获每个操作符调用的堆栈追踪的代价。其行为类似于<a href="#debug-activate">激活调试模式 - 又名回溯</a>，但是没有运行时的性能开销。</p>
</div>
<div class="paragraph">
<p>要在你的应用程序使用它，必须将其添加为依赖型。</p>
</div>
<div class="paragraph">
<p>下面的例子显示了如何在Maven中添加 <code>reactor-tools</code> 依赖项：</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. Maven中的reactor-tools, 在 <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用了<a href="#getting">BOM</a>，你不需要指定 <code>&lt;version&gt;</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子显示了如何在Gradle中添加 <code>reactor-tools</code> 依赖型：</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. Gradle中的reactor-tools, 更改 <code>dependencies</code> 块</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
   compile 'io.projectreactor:reactor-tools'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当然需要显式地初始化它：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ReactorDebugAgent.init();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
由于该工具会在加载的时候会增强你的类，所以最好把它放在main(String[])方法中的所有其它功能之前：
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static void main(String[] args) {
    ReactorDebugAgent.init();
    SpringApplication.run(Application.class, args);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你不能及早地（例如在测试中）运行初始化，你也可以对现有的类进行重新处理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ReactorDebugAgent.init();
ReactorDebugAgent.processExistingClasses();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
请注意，由于需要迭代所有加载的类并应用转换，重新处理需要花费几秒的时间。仅在一些调用位置没有增强时使用它。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_局限性"><a class="anchor" href="#_局限性"></a>7.4.1. 局限性</h4>
<div class="paragraph">
<p><code>ReactorDebugAgent</code> 作为一个Java代理实现，并使用 <a href="https://bytebuddy.net/#/">ByteBuddy</a> 执行自我附加。自我附加可能不适用某些JVM，请参考ByteBuddy的文档获取更多详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_作为java代理运行reactordebugagent"><a class="anchor" href="#_作为java代理运行reactordebugagent"></a>7.4.2. 作为Java代理运行ReactorDebugAgent</h4>
<div class="paragraph">
<p>如果你的环境不支持ByteBuddy的自我附加，你可以将 <code>reactor-tools</code> 作为Java代理运行：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">java -javaagent reactor-tools.jar -jar app.jar</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在构建时运行reactordebugagent"><a class="anchor" href="#_在构建时运行reactordebugagent"></a>7.4.3. 在构建时运行ReactorDebugAgent</h4>
<div class="paragraph">
<p>也可以在构建时运行 <code>reactor-tools</code>，要做到这一点，你需要将其作为ByteBuddy的构建工具的插件来使用。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
该转换将只应用于你的项目的类，类路径下的库并不会被增强。
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 23. reactor-tools 和 <a href="https://github.com/raphw/byte-buddy/tree/byte-buddy-1.10.9/byte-buddy-maven-plugin">ByteBuddy的Maven插件</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
		&lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
		<i class="conum" data-value="1"></i><b>(1)</b>
		&lt;classifier&gt;original&lt;/classifier&gt; <i class="conum" data-value="2"></i><b>(2)</b>
		&lt;scope&gt;runtime&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;
			&lt;artifactId&gt;byte-buddy-maven-plugin&lt;/artifactId&gt;
			&lt;configuration&gt;
				&lt;transformations&gt;
					&lt;transformation&gt;
						&lt;plugin&gt;reactor.tools.agent.ReactorDebugByteBuddyPlugin&lt;/plugin&gt;
					&lt;/transformation&gt;
				&lt;/transformations&gt;
			&lt;/configuration&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用了<a href="#getting">BOM</a>，你不需要指定 <code>&lt;version&gt;</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这里的 <code>classifier</code> 很重要。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 24. reactor-tools 和 <a href="https://github.com/raphw/byte-buddy/tree/byte-buddy-1.10.9/byte-buddy-gradle-plugin">ByteBuddy的Gradle插件</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
	id 'net.bytebuddy.byte-buddy-gradle-plugin' version '1.10.9'
}

configurations {
	byteBuddyPlugin
}

dependencies {
	byteBuddyPlugin(
			group: 'io.projectreactor',
			name: 'reactor-tools',
			<i class="conum" data-value="1"></i><b>(1)</b>
			classifier: 'original', <i class="conum" data-value="2"></i><b>(2)</b>
	)
}

byteBuddy {
	transformation {
		plugin = "reactor.tools.agent.ReactorDebugByteBuddyPlugin"
		classPath = configurations.byteBuddyPlugin
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用了<a href="#getting">BOM</a>，你不需要指定 <code>&lt;version&gt;</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这里的 <code>classifier</code> 很重要。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_记录序列"><a class="anchor" href="#_记录序列"></a>7.5. 记录序列</h3>
<div class="paragraph">
<p>除了堆栈追踪调试和分析之外，在工具包中有另外一个强大的工具是在异步序列中追踪和记录事件的能力。</p>
</div>
<div class="paragraph">
<p><code>log()</code> 操作符可以做到这一点。链接在序列中，能窥视它上游的每个 <code>Flux</code> 或 <code>Mono</code> 事件（包括 <code>onNext</code>，<code>onError</code> 和 `onComplete`以及订阅，取消和请求）。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">关于执行日志的说明</div>
<div class="paragraph">
<p><code>log</code> 操作符使用 <code>Loggers</code> 工具类，它通过 <code>SLF4J</code> 提取常用的日志框架，如Log4J和Logback，如果SLF4J不可用时，则默认记录到控制台。</p>
</div>
<div class="paragraph">
<p>控制台后备方案使用 <code>System.err</code> 用于 <code>WARN</code> 和 <code>ERROR</code> 日志级别，其它的都是 <code>System.out</code>。</p>
</div>
<div class="paragraph">
<p>如果你更喜欢JDK的 <code>java.util.logging</code> 的后备方案，比如在3.0.x中，你可以通过将 <code>reactor.logging.fallback</code> 系统属性设置为 <code>JDK</code> 来得到。</p>
</div>
<div class="paragraph">
<p>在所有的情况下，当在生产环境中记录日志时，<strong>你应该注意配置底层日志框架尽量使用异步非阻塞的方式</strong>&#8201;&#8212;&#8201;例如，Logback中的 <code>AsyncAppender</code> 或 Log4j 2中的 <code>AsyncLogger</code>。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，假设我们已经配置且激活了Logback，并配置了一条像 <code>range(1,10).take(3)</code> 这样的链。通过在 <code>take</code> 之前放置一个 <code>log</code>，我们可以深入了解其工作原理，以及它向上游传播什么样的事件，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; flux = Flux.range(1, 10)
                         .log()
                         .take(3);
flux.subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将打印出以下内容（通过日志记录的控制台附加器）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">10:45:20.200 [main] INFO  reactor.Flux.Range.1 - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription) <i class="conum" data-value="1"></i><b>(1)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | request(unbounded) <i class="conum" data-value="2"></i><b>(2)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(1) <i class="conum" data-value="3"></i><b>(3)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(2)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(3)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | cancel() <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，除了记录器自己的格式（时间，线程，级别，消息），<code>log()</code> 操作符还可以用其自己的格式输出一些内容：</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用的操作符在链中多次出现，<code>reactor.Flux.Range.1</code> 是日志的自动分类。它可以让你区分哪个操作符的事件被记录（在这种情况下，是 <code>range</code>）。你可以通过 <code>log(String)</code> 方法签名使用自定义类别覆盖标识符，在几个分开的字符后，实际的事件被打印出来。这里，我们得到一次 <code>onSubscribe</code> 调用，一次 <code>request</code> 调用， 三次 <code>onNext</code> 和一次 <code>cancel</code> 调用。对于第一行， 在`onSubscribe` 中，我们得到了 <code>Subscriber</code> 的实现，通常是对应于操作符的具体实现。在方括号之间，我们得到额外的信息，包括操作符是否可以通过同步或异步结合进行自动优化。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在第二行，我们可以看到，一个从下游向上传播的无界的请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后range连续发送三个值。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在最后一行，我们看到 <code>cancel()</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>最后一行（4）是最有意思的。我们可以看到这里的 <code>take</code> 的作用。在看到足够多的元素发射后，将序列剪短。总而言之，一旦发射了用户请求的数量后，<code>take()</code> 就会导致源 <code>cancel()</code>。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/debugging.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#debugging">调试Reactor</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="metrics"><a class="anchor" href="#metrics"></a>8. 暴露Reactor的指标</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor项目是一个旨在提高性能和更好地利用资源的库。但是要真正了解一个系统的性能，最好是能够监视其各种组件。</p>
</div>
<div class="paragraph">
<p>这也是为什么Reactor提供了一个内置的 <a href="https://micrometer.io">Micrometer</a> 集成的原因。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果Micrometer不在类路径上，指标将是不可操作的。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_调度器指标"><a class="anchor" href="#_调度器指标"></a>8.1. 调度器指标</h3>
<div class="paragraph">
<p>Reactor中的每个异步操作都是通过<a href="#schedulers">线程和调度器</a>中描述的调度器抽象来完成的。这就是为什么监控你的调度器是很重要的，注意关键指标开始出现可疑的情况并作出相应反应。</p>
</div>
<div class="paragraph">
<p>要启用调度器指标，你需要使用以下方法：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Schedulers.enableMetrics();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
在调度器创建时执行检测。建议尽早调用该方法。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你使用的是Spring Boot，那么最好将调用放在 <code>SpringApplication.run(Application.class, args)</code> 调用之前。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一旦调度器指标被启用，并且只要它在类路径上，Reactor将使用Micrometer的支持来检测背后的大多数调度器的执行器。</p>
</div>
<div class="paragraph">
<p>关于暴露的指标，请参考 <a href="http://micrometer.io/docs/ref/jvm">Micrometer的文档</a>，如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>executor_active_threads</p>
</li>
<li>
<p>executor_completed_tasks_total</p>
</li>
<li>
<p>executor_pool_size_threads</p>
</li>
<li>
<p>executor_queued_tasks</p>
</li>
<li>
<p>executor_secounds_{count, max, sum}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于一个调度器可能有多个执行器，每个执行器指标都有一个 <code>reactor_scheduler_id</code> 标签。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Grafana + Prometheus用户可以使用 <a href="https://raw.githubusercontent.com/reactor/reactor-monitoring-demo/master/dashboards/schedulers.json">预建仪表板</a>，其中包含线程，已完成任务，任务队列和其它有用的指标。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_生产者指标"><a class="anchor" href="#_生产者指标"></a>8.2. 生产者指标</h3>
<div class="paragraph">
<p>有时，在响应式管道的某个阶段能够记录指标是非常有用的。</p>
</div>
<div class="paragraph">
<p>一种方法是将值手动推送到你选择的指标后端。另一种选择是使用Reactor内置的 <code>Flux</code>/<code>Mono</code> 的指标集成，并解析它们。</p>
</div>
<div class="paragraph">
<p>考虑下面的管道：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">listenToEvents()
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了启用这个 <code>Flux</code>（从 <code>listenToEvents()</code> 返回的） 的指标，我们需要为其命名并启用指标收集：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">listenToEvents()
    .name("events") <i class="conum" data-value="1"></i><b>(1)</b>
    .metrics() <i class="conum" data-value="2"></i><b>(2)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在这一阶段，每个指标都将会被确定为 “事件”。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Flux#metrics</code> 操作符启用指标报告并使用管道中的最后一个的名称。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>只需要加上这两个操作符，就会暴露出一大堆有用的指标!</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">指标名</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.subscribed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">统计订阅了多少响应式序列</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.malformed.source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">统计从异常的源（即onComplete之后的onNext）接收到的事件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.requested</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">分发概括</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">统计所有订阅者对命名Flux的请求量，直到至少有一个无界数量的请求为止</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.onNext.delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计时器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计量onNext信号之间的延迟</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor.flow.duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计时器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从订阅到序列终止或取消之间的持续时间。添加状态标签以指定什么事件导致计时器结束（<code>onComplete</code>、<code>onError</code>、<code>cancel</code>）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>想知道你的事件处理由于某些错误而重启了多少次？请阅读 <code>reactor.subscribed</code>，因为 <code>retry()</code> 操作符在发生错误时会重新订阅生产者源。</p>
</div>
<div class="paragraph">
<p>对 “每秒的事件数” 指标感兴趣？测量 <code>reactor.onNext.delay</code> 的计数的速率。</p>
</div>
<div class="paragraph">
<p>想在监听器抛出错误时得到告警？带 <code>status=error</code> 标签的 <code>reactor.flow.duration</code> 是你的朋友。</p>
</div>
<div class="sect3">
<h4 id="_常用标签"><a class="anchor" href="#_常用标签"></a>8.2.1. 常用标签</h4>
<div class="paragraph">
<p>每个指标都有以下共同的标签：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标签名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">样例</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">生产者类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"Mono"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">flow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前流的名称，由 <code>.name()</code> 操作符设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"events"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_自定义标签"><a class="anchor" href="#_自定义标签"></a>8.2.2. 自定义标签</h4>
<div class="paragraph">
<p>允许用户添加自定义标签到其响应式链：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">listenToEvents()
    .tag("source", "kafka") <i class="conum" data-value="1"></i><b>(1)</b>
    .name("events")
    .metrics() <i class="conum" data-value="2"></i><b>(2)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置一个自定义标签“source”为“kafka”。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>除了上述常见的标签外，所有报告的指标都会有 <code>source=kafka</code> 标签。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/metrics.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#metrics">暴露Reactor的指标</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced"><a class="anchor" href="#advanced"></a>9. 高级特性和概念</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章涵盖了Reactor的高级特性和概念，包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#advanced-mutualizing-operator-usage">互用操作符用法</a></p>
</li>
<li>
<p><a href="#reactor.hotCold">热与冷</a></p>
</li>
<li>
<p><a href="#advanced-broadcast-multiple-subscribers-connectableflux">使用 <code>ConnectableFlux</code> 向多个订阅者广播</a></p>
</li>
<li>
<p><a href="#advanced-three-sorts-batching">三种批处理</a></p>
</li>
<li>
<p><a href="#advanced-parallelizing-parralelflux">用 <code>ParallelFlux</code> 并行化工作</a></p>
</li>
<li>
<p><a href="#scheduler-factory">替换默认的 <code>Schedulers</code></a></p>
</li>
<li>
<p><a href="#hooks">使用全局钩子</a></p>
</li>
<li>
<p><a href="#context">为响应式序列添加上下文</a></p>
</li>
<li>
<p><a href="#null-safety">空安全</a></p>
</li>
<li>
<p><a href="#cleanup">处理需要清理的对象</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="advanced-mutualizing-operator-usage"><a class="anchor" href="#advanced-mutualizing-operator-usage"></a>9.1. 互用操作符用法</h3>
<div class="paragraph">
<p>从简洁的代码角度来看，代码复用通常是一件好事。Reactor提供了一些可以帮助你重用和互用代码的方式，特别是对于你可能想在代码库中经常应用的操作符或操作符的组合。如果你想将操作符链作为配方，你可以创建一个操作符 &#8220;食谱&#8221; 的配方。</p>
</div>
<div class="sect3">
<h4 id="_使用_transform_操作符"><a class="anchor" href="#_使用_transform_操作符"></a>9.1.1. 使用 <code>transform</code> 操作符</h4>
<div class="paragraph">
<p><code>transform</code> 操作符可以让你将操作符链的一部分封装成一个函数。这个函数在组装时被应用到原始操作链上，使用封装的操作符来进行增强。这样做会将相同的操作应用于序列的所有订阅者，基本上相当于直接链接操作符。下面的代码显示了一个例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap =
f -&gt; f.filter(color -&gt; !color.equals("orange"))
      .map(String::toUpperCase);

Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
	.doOnNext(System.out::println)
	.transform(filterAndMap)
	.subscribe(d -&gt; System.out.println("Subscriber to Transformed MapAndFilter: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了 <code>transform</code> 操作符如何封装流：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-transform.png" alt="转换操作符：封装流">
</div>
</div>
<div class="paragraph">
<p>前面的例子产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber to Transformed MapAndFilter: BLUE
green
Subscriber to Transformed MapAndFilter: GREEN
orange
purple
Subscriber to Transformed MapAndFilter: PURPLE</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_transformdeferred_操作符"><a class="anchor" href="#_使用_transformdeferred_操作符"></a>9.1.2. 使用 <code>transformDeferred</code> 操作符</h4>
<div class="paragraph">
<p><code>transformDeferred</code> 操作符类似于 <code>transform</code>，也可以让你将操作符封装在一个函数中。主要区别在于，此函数是 <em>基于每个订阅者</em> 应用于原始序列。这意味着这个函数实际上可以为每个订阅者（通过维护某种状态）产生不同的操作符链。下面的代码显示了一个例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicInteger ai = new AtomicInteger();
Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap = f -&gt; {
	if (ai.incrementAndGet() == 1) {
return f.filter(color -&gt; !color.equals("orange"))
        .map(String::toUpperCase);
	}
	return f.filter(color -&gt; !color.equals("purple"))
	        .map(String::toUpperCase);
};

Flux&lt;String&gt; composedFlux =
Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
    .doOnNext(System.out::println)
    .transformDeferred(filterAndMap);

composedFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Composed MapAndFilter :"+d));
composedFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Composed MapAndFilter: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了 <code>transformDeferred</code> 操作符如何处理每个订阅者的转换：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-compose.png" alt="组合操作符：每个订阅者转换">
</div>
</div>
<div class="paragraph">
<p>上面的例子产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber 1 to Composed MapAndFilter :BLUE
green
Subscriber 1 to Composed MapAndFilter :GREEN
orange
purple
Subscriber 1 to Composed MapAndFilter :PURPLE
blue
Subscriber 2 to Composed MapAndFilter: BLUE
green
Subscriber 2 to Composed MapAndFilter: GREEN
orange
Subscriber 2 to Composed MapAndFilter: ORANGE
purple</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor.hotCold"><a class="anchor" href="#reactor.hotCold"></a>9.2. 热与冷</h3>
<div class="paragraph">
<p>到目前为止，我们已经认为所有的 <code>Flux</code>（和 <code>Mono</code>）都是一样的：它们都表示一个异步的数据序列，在订阅之前没有任何事情发生。</p>
</div>
<div class="paragraph">
<p>但实际上，生产者有两大派系：热与冷。</p>
</div>
<div class="paragraph">
<p>前面的描述适用于冷的这类生产者。它们会为每个订阅重新生成数据。如果没有创建订阅，数据永远不会被生成。</p>
</div>
<div class="paragraph">
<p>考虑一个HTTP请求：每个新的订阅者触发一次HTTP调用，但是如果没有人对结果感兴趣，就不进行调用。</p>
</div>
<div class="paragraph">
<p>另一方面，热的生产者不依赖于任何数量的订阅者。它们可能会立即开始发布数据，并在每当有一个新的 <code>Subscriber</code> 出现时（在这种情况下，当它订阅 <em>后</em>，订阅者只能看到发出的新的元素）继续这样做。对于热的生产者来说，在订阅前确实会发生 <em>一些事情</em>。</p>
</div>
<div class="paragraph">
<p>Reactor中为数不多的热操作符的一个例子就是 <code>just</code>：在组装时直接获取值，然后向订阅它的任何人重新发出。再次类比于HTTP的调用，如果获取的数据是一次HTTP调用的结果，那么只有一次网络调用，即初始化 <code>just</code> 时。</p>
</div>
<div class="paragraph">
<p>要将 <code>just</code> 转换成一个冷的生产者，你可以使用 <code>defer</code>。在我们的示例中，它将HTTP请求推迟到订阅的时候（并会导致对于每个新的订阅者有单独的网络调用）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Reactor中的绝大多数热生产者扩展了 <code>Processor</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>考虑另外两个例子。下面的代码显示的是第一个例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; source = Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
                          .map(String::toUpperCase);

source.subscribe(d -&gt; System.out.println("Subscriber 1: "+d));
source.subscribe(d -&gt; System.out.println("Subscriber 2: "+d));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个例子产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1: BLUE
Subscriber 1: GREEN
Subscriber 1: ORANGE
Subscriber 1: PURPLE
Subscriber 2: BLUE
Subscriber 2: GREEN
Subscriber 2: ORANGE
Subscriber 2: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了重播行为：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-cold.png" alt="Replaying behavior">
</div>
</div>
<div class="paragraph">
<p>两个订阅者都能捕获所有的四种颜色，因为每个订阅者都会导致操作符在 <code>Flux</code> 上定义的过程运行。</p>
</div>
<div class="paragraph">
<p>将第一个例子和第二个例子进行比较，如下代码所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">DirectProcessor&lt;String&gt; hotSource = DirectProcessor.create();

Flux&lt;String&gt; hotFlux = hotSource.map(String::toUpperCase);


hotFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Hot Source: "+d));

hotSource.onNext("blue");
hotSource.onNext("green");

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Hot Source: "+d));

hotSource.onNext("orange");
hotSource.onNext("purple");
hotSource.onComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第二个例子产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1 to Hot Source: BLUE
Subscriber 1 to Hot Source: GREEN
Subscriber 1 to Hot Source: ORANGE
Subscriber 2 to Hot Source: ORANGE
Subscriber 1 to Hot Source: PURPLE
Subscriber 2 to Hot Source: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了订阅是如何广播的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gs-hot.png" alt="广播订阅">
</div>
</div>
<div class="paragraph">
<p>订阅者1捕获了所有四种颜色。在前面两种颜色产生后创建订阅者2，只捕获了后面两种颜色。这种差异导致了 <code>ORANGE</code> 和 <code>PURPLE</code> 的输出加倍。Flux上操作符所描述的过程，无论订阅何时被添加，都会运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-broadcast-multiple-subscribers-connectableflux"><a class="anchor" href="#advanced-broadcast-multiple-subscribers-connectableflux"></a>9.3. 使用 <code>ConnectableFlux</code> 向多个订阅者广播</h3>
<div class="paragraph">
<p>有时，你可能不想延迟，只是推迟某些处理到订阅者的订阅时候，而实际上是想让他们中的几个聚合，然后触发订阅和数据生成。</p>
</div>
<div class="paragraph">
<p>这就是 <code>ConnectableFlux</code> 的作用。<code>Flux</code> API 中包含了两个主要的模式，可以返回一个 <code>ConnectableFlux</code>：<code>publish</code> 和 <code>replay</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>publish</code> 尝试动态地维护各个订阅者的需求，在背压方面，通过转发这些请求给源。最值得注意的是，如果任何订阅者有一个挂起的请求 <code>0</code>，<code>publish</code> 将暂停向源的请求。</p>
</li>
<li>
<p><code>replay</code> 缓冲第一次订阅开始的数据，直到达到可配置的限制（在时间和缓冲区大小上）。它将重新发出数据给后续订阅者。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ConnectableFlux</code> 提供了额外的方法来管理下游订阅与原始源的订阅。这些额外方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一旦对 <code>Flux</code> 达到足够多的订阅，可以手动调用 <code>connect()</code>。这样将触发对上游源的订阅。</p>
</li>
<li>
<p>一旦达到 <code>n</code> 个订阅，<code>autoConnect(n)</code> 可以自动做相同的事情。</p>
</li>
<li>
<p><code>refCount(n)</code> 不仅自动跟踪到来的订阅，而且还可以检测这些订阅何时被取消。如果跟踪的订阅者不足，则源将 ”<code>disconnected</code>“，如果稍后有额外的订阅者出现，则将导致对源产生新的订阅。</p>
</li>
<li>
<p><code>refCount(int, Duration)</code> 增加了一个 &#8220;宽限期&#8221;。一旦跟踪的订阅者数量太低，它会在断开源之前等待 <code>Duration</code> 持续时间，有可能让足够多的新的订阅者进入并再次超过连接阀值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请看下面的例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

ConnectableFlux&lt;Integer&gt; co = source.publish();

co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});

System.out.println("done subscribing");
Thread.sleep(500);
System.out.println("will now connect");

co.connect();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>done subscribing
will now connect
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的代码使用 <code>autoConnect</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

Flux&lt;Integer&gt; autoCo = source.publish().autoConnect(2);

autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
System.out.println("subscribed first");
Thread.sleep(500);
System.out.println("subscribing second");
autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的代码产生下面的输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>subscribed first
subscribing second
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-three-sorts-batching"><a class="anchor" href="#advanced-three-sorts-batching"></a>9.4. 三种批处理</h3>
<div class="paragraph">
<p>当你有很多的元素并且想把它们分批的时候，在Reactor中，你大致有三个解决方案：分组，窗口化和缓冲。这三者概念上接近，因为它们将一个 <code>Flux&lt;T&gt;</code> 重新分配到一个集合中。分组和窗口化会创建一个 <code>Flux&lt;Flux&lt;T&gt;&gt;</code>，而缓冲则将聚合到一个 <code>Collection&lt;T&gt;</code>。</p>
</div>
<div class="sect3">
<h4 id="_用_fluxgroupedfluxt_分组"><a class="anchor" href="#_用_fluxgroupedfluxt_分组"></a>9.4.1. 用 <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> 分组</h4>
<div class="paragraph">
<p>分组是将源的 <code>Flux&lt;T&gt;</code> 分成多个批次的行为，每个批次匹配一个键。</p>
</div>
<div class="paragraph">
<p>相关的操作符是 <code>groupBy</code>。</p>
</div>
<div class="paragraph">
<p>每个组都表示为一个 <code>GroupedFlux&lt;T&gt;</code>，你可以通过调用其 <code>key()</code> 方法来得到键。</p>
</div>
<div class="paragraph">
<p>组的内容的连续性是没有必要的。一旦一个源的元素产生一个新的键，键的组就会被打开，并且与该键匹配的元素就会出现在该组中（几个组可以同时打开）。</p>
</div>
<div class="paragraph">
<p>这意味着组：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>总是不相交的（一个源元素只属于一个组）。</p>
</li>
<li>
<p>可以包含原始序列中不同位置的元素。</p>
</li>
<li>
<p>永不为空。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下面的例子按值是偶数还是奇数进行分组：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.groupBy(i -&gt; i % 2 == 0 ? "even" : "odd")
		.concatMap(g -&gt; g.defaultIfEmpty(-1) //如果是空的组，就显示出来
				.map(String::valueOf) //映射为字符
				.startWith(g.key())) //以组的键开始
	)
	.expectNext("odd", "1", "3", "5", "11", "13")
	.expectNext("even", "2", "4", "6", "12")
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
分组最适合具有中等到较低组数的情况。还必须强制性地使用组（例如，通过 <code>flatMap</code>），以便 <code>groupBy</code> 继续从上游获取数据并为更多的组提供数据。有时，这两个约束成倍增加并导致挂起，例如当基数较高且 <code>flatMap</code> 消费组的并发性太低时。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_fluxfluxt_窗口化"><a class="anchor" href="#_fluxfluxt_窗口化"></a>9.4.2. <code>Flux&lt;Flux&lt;T&gt;&gt;</code> 窗口化</h4>
<div class="paragraph">
<p>窗口化是将源 <code>Flux&lt;T&gt;</code> 根据大小，时间，定义边界的谓词或边界定义的 <code>Publisher</code> 的标准， 将源 <code>Flux&lt;T&gt;</code> 拆分为 <em>窗口</em> 的操作。</p>
</div>
<div class="paragraph">
<p>相关的操作符是 <code>window</code>，<code>windowTimeout</code>，<code>windowUntil</code>，<code>windowWhile</code> 和 <code>windowWhen</code>。</p>
</div>
<div class="paragraph">
<p>与 <code>groupBy</code> 不同的是，后者是根据传入的键随机重叠，窗口（大多数时候）是按顺序打开的。</p>
</div>
<div class="paragraph">
<p>不过，有些形式依然是可以重叠的。例如，在 <code>window(int maxSize, int skip)</code> 中，<code>maxSize</code> 参数是窗口关闭后的元素数，而 <code>skip</code> 参数是当新的窗口开启后源中元素的数量。如果 <code>maxSize &gt; skip</code>，则会在前一个窗口关闭前打开一个新的窗口，然后两个窗口重叠。</p>
</div>
<div class="paragraph">
<p>下面的例子显示的是重叠的窗口：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.range(1, 10)
		.window(5, 3) //重叠窗口
		.concatMap(g -&gt; g.defaultIfEmpty(-1)) //空窗口显示为-1
	)
		.expectNext(1, 2, 3, 4, 5)
		.expectNext(4, 5, 6, 7, 8)
		.expectNext(7, 8, 9, 10)
		.expectNext(10)
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用相反的配置（<code>maxSize</code> &lt; <code>skip</code>），某些源的元素被丢弃，不属于任何窗口。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在通过 <code>windowUntil</code> 和 <code>windowWhile</code> 进行基于谓词的窗口化的情况下，后续源的元素与谓词不匹配也可能会导致空窗口，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.windowWhile(i -&gt; i % 2 == 0)
		.concatMap(g -&gt; g.defaultIfEmpty(-1))
	)
		.expectNext(-1, -1, -1) //分别触发奇数 1 3 5
		.expectNext(2, 4, 6) // 11 触发
		.expectNext(12) // 13 触发
		// 但是没有发出空的完成窗口（将包含额外的匹配元素）
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_用_fluxlistt_缓冲"><a class="anchor" href="#_用_fluxlistt_缓冲"></a>9.4.3. 用 <code>Flux&lt;List&lt;T&gt;&gt;</code> 缓冲</h4>
<div class="paragraph">
<p>缓冲类似于窗口化，但有以下的不同：与产生 <em>窗口</em>（每个都是一个 <code>Flux&lt;T&gt;</code>）相反，它产生 <em>缓冲区</em>（即 <code>Collection&lt;T&gt;</code>-- 默认情况下为 <code>List&lt;T&gt;</code>）。</p>
</div>
<div class="paragraph">
<p>用于缓冲的操作符与窗口化操作符相同：<code>buffer</code>，<code>bufferTimeout</code>，<code>bufferUntil</code>，<code>bufferWhile</code>，和 <code>bufferWhen</code>。</p>
</div>
<div class="paragraph">
<p>当相应的窗口化操作符打开一个窗口时，缓冲操作符创建一个新的集合并开始向其中添加元素。当窗口关闭时，缓冲操作符发出集合。</p>
</div>
<div class="paragraph">
<p>缓冲也可以导致源元素丢弃或具有重叠的缓冲区，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.range(1, 10)
		.buffer(5, 3) //重叠缓冲区
	)
		.expectNext(Arrays.asList(1, 2, 3, 4, 5))
		.expectNext(Arrays.asList(4, 5, 6, 7, 8))
		.expectNext(Arrays.asList(7, 8, 9, 10))
		.expectNext(Collections.singletonList(10))
		.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>与在窗口化中不同，<code>bufferUntil</code> 和 <code>bufferWhile</code> 不会发出空的缓冲区，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StepVerifier.create(
	Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
		.bufferWhile(i -&gt; i % 2 == 0)
	)
	.expectNext(Arrays.asList(2, 4, 6)) // 11 触发
	.expectNext(Collections.singletonList(12)) // 13 触发
	.verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-parallelizing-parralelflux"><a class="anchor" href="#advanced-parallelizing-parralelflux"></a>9.5. 用 <code>ParallelFlux</code> 并行化工作</h3>
<div class="paragraph">
<p>如今，随着多核架构变得普遍，能够轻松实现并行化工作很重要。Reactor提供了一种特殊的 <code>ParallelFlux</code>，它暴露了为并行化而优化的操作符，从而帮助我们实现了这一点。</p>
</div>
<div class="paragraph">
<p>要获得一个 <code>ParallelFlux</code>，你可以在任何 <code>Flux</code> 上使用 <code>parallel()</code> 操作符。该方法本身并不会使工作并行化。而是将负载划分为 &#8220;轨道&#8221;（默认情况下，轨道的数量与CPU的核数相同）。</p>
</div>
<div class="paragraph">
<p>为了告诉生成的 <code>ParallelFlux</code> 在哪里运行每个轨道（并且，通过扩展，并行化地运行轨道），你必须使用 <code>runOn(Scheduler)</code>。注意有一个推荐的专用的 <code>Scheduler</code> 用于并行化工作：<code>Schedulers.parallel()</code>。</p>
</div>
<div class="paragraph">
<p>比较一下下面两个例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.range(1, 10)
    .parallel(2) <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们强制使用多个轨道而不是依赖于CPU的核数。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个例子产生以下输出：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>main -&gt; 1
main -&gt; 2
main -&gt; 3
main -&gt; 4
main -&gt; 5
main -&gt; 6
main -&gt; 7
main -&gt; 8
main -&gt; 9
main -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第二个例子正确地并行化在两个线程上，如下面的输出所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>parallel-1 -&gt; 1
parallel-2 -&gt; 2
parallel-1 -&gt; 3
parallel-2 -&gt; 4
parallel-1 -&gt; 5
parallel-2 -&gt; 6
parallel-1 -&gt; 7
parallel-1 -&gt; 9
parallel-2 -&gt; 8
parallel-2 -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你一旦并行处理你的序列，你想要恢复为 &#8220;正常&#8221; 的 <code>Flux</code>，并按顺序的方式应用其余的操作符链，则可以使用 <code>ParallelFlux</code> 上的 <code>sequential()</code> 方法。</p>
</div>
<div class="paragraph">
<p>注意，如果你用一个 <code>Subscriber</code> <code>subscribe</code> <code>ParallelFlux</code>，则会隐式的应用 <code>sequential()</code>，但当使用基于lambda形式的 <code>subscribe</code> 则不能。</p>
</div>
<div class="paragraph">
<p>还要注意的是， <code>subscribe(Subscriber&lt;T&gt;)</code> 合并了所有的轨道，而 <code>subscribe(Consumer&lt;T&gt;)</code> 运行所有的轨道。如果 <code>subscribe()</code> 方法具有lambda，则每个lambda执行的次数与轨道执行的次数相同。</p>
</div>
<div class="paragraph">
<p>你还可以通过 <code>groups()</code> 方法来访问各个轨道或 &#8220;groups&#8221; 作为一个 <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code>，并通过 <code>composeGroup()</code> 方法对其应用其他的操作符。</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduler-factory"><a class="anchor" href="#scheduler-factory"></a>9.6. 替换默认的 <code>Schedulers</code></h3>
<div class="paragraph">
<p>正如我们在<a href="#schedulers">线程和调度器</a>一节中所描述的那样，Reactor核心自带了几个 <code>Scheduler</code> 实现。虽然你总是可以通过 <code>new*</code> 工厂方法创建新的实例，但每个 <code>Scheduler</code> 风格都有一个默认的单例实例，可直接通过工厂方法（例如 <code>Schedulers.boundedElastic()</code> 与 <code>Schedulers.newBoundedElastic(&#8230;&#8203;)</code>）访问。</p>
</div>
<div class="paragraph">
<p>这些默认的实例是操作符使用的，如果没有明确指定一个 <code>Scheduler</code> 时，需要一个 <code>Scheduler</code> 实例。例如，<code>Flux#delayElements(Duration)</code> 使用 <code>Schedulers.parallel()</code> 实例。</p>
</div>
<div class="paragraph">
<p>但是，在某些情况下，你可能需要以交叉的方式使用其他东西来更改这些默认实例，而不必确保你调用的每个操作符都有你指定的 <code>Scheduler</code> 作为参数。一个例子就是通过包装实际的调度器来测量每个调度任务花费的时间，以进行检测的目的。换句话说，你可能想要改变默认的 <code>Schedulers</code>。</p>
</div>
<div class="paragraph">
<p>可以通过 <code>Schedulers.Factory</code> 类来更改默认的调度器。默认情况下，<code>Factory</code> 通过类似的名称方法创建所有标准的 <code>Scheduler</code>。你可以用你的自定义实现覆盖这些方法。</p>
</div>
<div class="paragraph">
<p>此外，该工厂还暴露了另一种自定义方法：<code>decorateExecutorService</code>。它在 <code>ScheduledExecutorService</code>（即使是非默认实例，例如通过调用 <code>Schedulers.newParallel()</code> 创建的）所支持的每个响应式核心 <code>Scheduler</code> 创建过程中调用。</p>
</div>
<div class="paragraph">
<p>这允许你调整要使用的 <code>ScheduledExecutorService</code>：默认的是暴露为 <code>Supplier</code>，并根据所配置的 <code>Scheduler</code> 的类型，你可以选择完全绕过该supplier并返回你自己的实例，或可以通过 <code>get()</code> 得到默认实例并将其包装。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
一旦你创建了满足你需要的 <code>Factory</code>，你必须通过调用 <code>Schedulers.setFactory(Factory)</code> 来对其进行设置。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后，在 <code>Schedulers</code> 中还有最后一个可定制的钩子：<code>onHandleError</code>。每当提交到 <code>Scheduler</code> 的 <code>Runnable</code> 任务抛出 <code>Exception</code>（注意，如果为运行任务的 <code>Thread</code> 设置了 <code>UncaughtExceptionHandler</code> 处理器，则处理器和钩子都会被调用）时调用。</p>
</div>
</div>
<div class="sect2">
<h3 id="hooks"><a class="anchor" href="#hooks"></a>9.7. 使用全局钩子</h3>
<div class="paragraph">
<p>Reactor还有另一类可配置的回调，Reactor操作符在各种情况下都会调用它们。它们都被设置在 <code>Hooks</code> 类中，分为三类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hooks-dropping">删除钩子</a></p>
</li>
<li>
<p><a href="#hooks-internal">内部错误钩子</a></p>
</li>
<li>
<p><a href="#hooks-assembly">组装钩子</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hooks-dropping"><a class="anchor" href="#hooks-dropping"></a>9.7.1. 删除钩子</h4>
<div class="paragraph">
<p>当源操作符不符合响应式流规范时，删除钩子将会被调用。这些错误超出了正常的执行路径（即，它们不能通过 <code>onError</code> 传播）。</p>
</div>
<div class="paragraph">
<p>通常，尽管之前已经调用了 <code>onCompleted</code>，<code>Publisher</code> 也会在操作符上调用 <code>onNext</code>。在这种情况下，<code>onNext</code> 的值将会被删除。对于无关的 <code>onError</code> 信号也是如此。</p>
</div>
<div class="paragraph">
<p>相应的钩子 <code>onNextDropped</code> 和 <code>onErrorDropped</code>，允许你对这些删除提供一个全局的 <code>Consumer</code>。例如，如果需要的话（因为不会到达响应式链的其他部分），你可以使用它来记录删除和清理与某个值相关的资源。</p>
</div>
<div class="paragraph">
<p>连续设置两次钩子是附加的：调用你提供的每个消费者。可以使用 <code>Hooks.resetOn*Dropped()</code> 方法将钩子完全重置为默认值。</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-internal"><a class="anchor" href="#hooks-internal"></a>9.7.2. 内部错误钩子</h4>
<div class="paragraph">
<p>在执行 <code>onNext</code>，<code>onError</code>，和 <code>onComplete</code> 方法时抛出意外的 <code>Exception</code> 时，操作符将调用 <code>onOperatorError</code> 钩子。</p>
</div>
<div class="paragraph">
<p>与前一类不同，这仍然是在正常的执行路径内。一个典型的例子就是带有map函数的 <code>map</code> 操作符抛出 <code>Exception</code>（例如，除以零）。在这一点上，仍然可以通过平常的 <code>onError</code> 方式，这正是操作符需要做的。</p>
</div>
<div class="paragraph">
<p>首先，它通过 <code>onOperatorError</code> 传递 <code>Exception</code>。这个钩子可以让你检查错误（以及相关的导致错误的值）并更改 <code>Exception</code>。当然，你可以在一旁做一些事情，比如记录日志并返回原始的 <code>Exception</code>。</p>
</div>
<div class="paragraph">
<p>注意，你可以多次设置 <code>onOperatorError</code> 钩子。可以为特定的 <code>BiFunction</code> 提供一个 <code>String</code> 标识符，后续不同键的调用将这些函数连接起来，这些函数都会被执行。另一方面，重复使用同一个键两次可以让你替换之前设置过的函数。</p>
</div>
<div class="paragraph">
<p>因此，可以完全重置（通过使用 <code>Hooks.resetOnOperatorError()</code>）钩子的默认行为或只对指定的 <code>key</code> 进行部分重置（通过使用 <code>Hooks.resetOnOperatorError(String)</code>）。</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-assembly"><a class="anchor" href="#hooks-assembly"></a>9.7.3. 组装钩子</h4>
<div class="paragraph">
<p>这些钩子和操作符的生命周期紧密相连。当一个操作符链组装（即实例化）时被调用。<code>onEachOperator</code> 通过返回不同的 <code>Publisher</code> 允许你动态改变组装在链中的每个操作符。<code>onLastOperator</code> 也是类似的，除了仅在链的最后一个操作符即 <code>subscribe</code> 调用之前被调用。</p>
</div>
<div class="paragraph">
<p>如果你想要用横切 <code>Subscriber</code> 实现来装饰所有的操作符，你可以研究一下 <code>Operators#lift*</code> 方法，以帮助你处理各种类型的Reactor的 <code>Publishers</code>（<code>Flux</code>，<code>Mono</code>，<code>ParallelFlux</code>，<code>GroupedFlux</code> 和 <code>ConnectableFlux</code>），以及它们的 <code>Fuseable</code> 版本。</p>
</div>
<div class="paragraph">
<p>像 <code>onOperatorError</code> 一样，这些钩子是累积的，可以用一个键来标识。它们也可以被部分或全部重置。</p>
</div>
</div>
<div class="sect3">
<h4 id="_预设钩子"><a class="anchor" href="#_预设钩子"></a>9.7.4. 预设钩子</h4>
<div class="paragraph">
<p><code>Hooks</code> 工具类提供了两个预设的钩子。你可以通过调用相应的方法来选择性的替换默认行为，而不是自己定义钩子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onNextDroppedFail()</code>：<code>onNextDropped</code> 用于抛出一个 <code>Exceptions.failWithCancel()</code> 异常。它现在默认记录在调试级别删除的值。要回到以前的默认抛出行为，使用 <code>onNextDroppedFail()</code>。</p>
</li>
<li>
<p><code>onOperatorDebug()</code>：此方法会激活 <a href="#debug-activate">调试模式</a>。它与 <code>onOperatorError</code> 钩子紧密相连，因此调用 <code>resetOnOperatorError()</code> 也能重置它。因为它在内部使用了一个特定的键，你也可以通过使用  <code>resetOnOperatorDebug()</code> 单独重置它。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>9.8. 为响应式序列添加上下文</h3>
<div class="paragraph">
<p>从命令式编程观点转换到响应式编程思维遇到的重大技术挑战之一在于如何应对线程化。</p>
</div>
<div class="paragraph">
<p>与你可能习惯的命令式编程相反，在响应式编程中，你可以使用 <code>Thread</code> 处理几个大致同时（实际上，在非阻塞的锁步）运行的异步序列。执行也可以很容易且经常从一个线程跳到另一个线程。</p>
</div>
<div class="paragraph">
<p>这种约定对于使用依赖于线程模型使得更 &#8220;稳定&#8221; 的特性的开发者相当困难，例如 <code>ThreadLocal</code>。因为它可以让你把数据与线程关联起来，但在响应式上下文中使用它就变得很棘手。因此，依赖于 <code>ThreadLocal</code> 的库与Reactor一起使用时，至少带来了新的挑战。最糟糕的是，它们不能工作或者甚至失败。使用Logback的MDC来存储并记录日志相关性ID就是这种情况的一个典型例子。</p>
</div>
<div class="paragraph">
<p>使用 <code>ThreadLocal</code> 的通常解决方法是通过使用（例如） <code>Tuple2&lt;T, C&gt;</code> 按顺序将上下文的数据 <code>C</code> 沿业务数据 <code>T</code> 移动。这确实看起来不好，并且将正交关系（上下文数据）泄露到方法和 <code>Flux</code> 签名中。</p>
</div>
<div class="paragraph">
<p>从 <code>3.1.0</code> 版本开始，Reactor自带了类似于 <code>ThreadLocal</code> 的一个高级功能，但可以应用于 <code>Flux</code> 或 <code>Mono</code> 而不是 <code>Thread</code>。这个特性称为 <code>Context</code>。</p>
</div>
<div class="paragraph">
<p>为了说明它是什么样子的，下面的例子同时从 <code>Context</code> 写入和获取：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext()
                                   .map( ctx -&gt; s + " " + ctx.get(key)))
                .subscriberContext(ctx -&gt; ctx.put(key, "World"));

StepVerifier.create(r)
            .expectNext("Hello World")
            .verifyComplete();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在下面的章节中，我们将介绍 <code>Context</code> 以及如何使用它，以便你最终能够理解前面的例子。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
这是一个更适合库开发人员的高级功能。它需要充分理解 <code>Subscription</code> 的生命周期，并且用于负责订阅的库。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="context.api"><a class="anchor" href="#context.api"></a>9.8.1. <code>Context</code> API</h4>
<div class="paragraph">
<p><code>Context</code> 是一个类似于 <code>Map</code> 的接口。它存储键值对，并允许你根据键获取你存储的值。更具体地说：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>键和值都属于 <code>Object</code> 类型，因此一个 <code>Context</code> 实例可以包含来源于不同库和源的任意数量且有巨大差异的值。</p>
</li>
<li>
<p><code>Context</code> 是不可更改的。</p>
</li>
<li>
<p>使用 <code>put(Object key, Object value)</code> 存储一个键值对，返回一个新的 <code>Context</code> 实例。你可以通过使用 <code>putAll(Context)</code> 将两个上下文合并到一个新的上下文中。</p>
</li>
<li>
<p>你可以通过 <code>hasKey(Object key)</code> 检查键是否存在。</p>
</li>
<li>
<p>使用 <code>getOrDefault(Object key, T defaultValue)</code> 来获取值（强转为 <code>T</code>）或如果 <code>Context</code> 实例没有该键则返回默认值。</p>
</li>
<li>
<p>使用 <code>getOrEmpty(Object key)</code> 获得一个 <code>Optional&lt;T&gt;</code>（<code>Context</code> 实例尝试强转存储值为 <code>T</code>）。</p>
</li>
<li>
<p>使用 <code>delete(Object key)</code> 来删除与某个键相关联的值，返回一个新的 <code>Context</code>。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当你创建一个 <code>Context</code> 时，可以通过使用静态的 <code>Context.of</code> 方法创建最多5个预值键值对的 <code>Context</code> 实例。它们取2，4，6，8或10个 <code>Object</code> 实例，每对 <code>Object</code> 实例都是要添加到 <code>Context</code> 的键值对。</p>
</div>
<div class="paragraph">
<p>另外，你也可以通过使用 <code>Context.empty()</code> 创建一个空的 <code>Context</code>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.write"><a class="anchor" href="#context.write"></a>9.8.2. 将 <code>Context</code> 绑定到 <code>Flux</code> 并编写</h4>
<div class="paragraph">
<p>为了使 <code>Context</code> 有用，它必须与一个特定的序列绑定，并且可以被链中的每个操作符访问。注意，操作符必须是Reactor的原生操作符，因为 <code>Context</code> 是Reactor所特有的。</p>
</div>
<div class="paragraph">
<p>实际上，<code>Context</code> 与链中的每个 <code>Subscriber</code> 所绑定。它使用 <code>Subscription</code> 传播机制使其在每个操作符上都可用，从最后的 <code>subscribe</code> 开始向上移动。</p>
</div>
<div class="paragraph">
<p>为了填充只能在订阅时完成的 <code>Context</code>，你需要使用 <code>subscriberContext</code> 操作符。</p>
</div>
<div class="paragraph">
<p><code>subscriberContext(Context)</code> 合并你提供的 <code>Context</code> 和来自下游（记住，<code>Context</code> 是从链的底部向上传播的）的 <code>Context</code>。这是通过调用 <code>putAll</code> 完成的，从而产生一个新的上游 <code>Context</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你也可以使用更高级的 <code>subscriberContext(Function&lt;Context, Context&gt;)</code>。它从下游接收 <code>Context</code> 的状态，它允许你根据需要增加或删除值，并返回新的 <code>Context</code> 来使用。你甚至可以决定返回一个完全不同的实例，尽管实际上不建议（这样做可能会影响到依赖于 <code>Context</code> 的第三方库）这样做。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.read"><a class="anchor" href="#context.read"></a>9.8.3. 读取 <code>Context</code></h4>
<div class="paragraph">
<p>一旦你填充了一个 <code>Context</code>，你就可以检索数据。在大多数情况下，将信息放到 <code>Context</code> 的职责是在最终用户这边，而利用这些信息是第三方库中，因为这些库通常在客户端代码的上游。</p>
</div>
<div class="paragraph">
<p>从上下文中读取数据的工具是 <code>Mono.subscriberContext()</code> 静态方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_简单的_context_示例"><a class="anchor" href="#_简单的_context_示例"></a>9.8.4. 简单的 <code>Context</code> 示例</h4>
<div class="paragraph">
<p>本节中的示例是为了更好地理解一些使用 <code>Context</code> 的注意事项。</p>
</div>
<div class="paragraph">
<p>首先，我们回顾一下我们引言中的简单示例，如下示例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext() <i class="conum" data-value="2"></i><b>(2)</b>
                                   .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
                .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello World") <i class="conum" data-value="4"></i><b>(4)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>操作符链以 <code>subscriberContext(Function)</code> 调用结束，该调用以 <code>"message"</code> 为键，将 <code>"World"</code> 放到 <code>Context</code> 中。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们对源元素进行 <code>flatMap</code>，用 <code>Mono.subscriberContext()</code> 具体化 <code>Context</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后，我们用 <code>map</code> 来提取与 <code>"message"</code> 相关联的数据，并将其与原来的值进行拼接。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>由此产生对 <code>Mono&lt;String&gt;</code> 发出 <code>"Hello World"</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
上面的数字与实际的行顺序没有关系。它代表的是执行顺序。即使 <code>subscriberContext</code> 是链的最后一部分，它仍然是最先被执行（由于它订阅时间性质以及订阅信号从下至上流动的事实）的那个。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在你的操作符链中，写入 <code>Context</code> 和读取 <code>Context</code> 的相对位置是很重要的。<code>Context</code> 是不可变的，其内容只能被它上面的操作符看到，如下面的例子：
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                     .subscriberContext(ctx -&gt; ctx.put(key, "World")) <i class="conum" data-value="1"></i><b>(1)</b>
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.getOrDefault(key, "Stranger")));  <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Stranger") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在链中写入 <code>Context</code> 的位置太在上面了。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>因此，在 <code>flatMap</code> 中，这里没有我们键关联的值。而是使用了一个默认值。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>由此产生的 <code>Mono&lt;String&gt;</code> 发出 <code>"Hello Stranger"</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子还演示了 <code>Context</code> 的不可变特性，以及 <code>Mono.subscriberContext()</code> 如何始终返回由 <code>subscriberContext</code> 调用设置的 <code>Context</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";

Mono&lt;String&gt; r = Mono.subscriberContext() <i class="conum" data-value="1"></i><b>(1)</b>
	.map( ctx -&gt; ctx.put(key, "Hello")) <i class="conum" data-value="2"></i><b>(2)</b>
	.flatMap( ctx -&gt; Mono.subscriberContext()) <i class="conum" data-value="3"></i><b>(3)</b>
	.map( ctx -&gt; ctx.getOrDefault(key,"Default")); <i class="conum" data-value="4"></i><b>(4)</b>

StepVerifier.create(r)
	.expectNext("Default") <i class="conum" data-value="5"></i><b>(5)</b>
	.verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们将 <code>Context</code> 具体化</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 <code>map</code> 中，我们试图将其转换</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们在 <code>flatMap</code> 中重新实现了 <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们尝试在 <code>Context</code> 中读取键</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>键的值没有设为 <code>"Hello"</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，在多次尝试将同一个键写入 <code>Context</code> 的情况下，写入的相对顺序也很重要。读取 <code>Context</code> 的操作符会看到最接近它们设置的值，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                .flatMap( s -&gt; Mono.subscriberContext()
                                   .map( ctx -&gt; s + " " + ctx.get(key)))
                .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
                .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>尝试写入键 <code>"message"</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>另一次尝试写入键 <code>"message"</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>map</code> 只看到了最接近它（在它下面）设置的值：<code>"Reactor"</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中，<code>Context</code> 在订阅期间被填充了 <code>"World"</code>。然后订阅信号向上移动，另一个写操作发生了。这就产生了第二个不可变的 <code>Context</code>，其值为 <code>"Reactor"</code>。之后，数据开始流动。<code>flatMap</code> 看到离他最近的 <code>Context</code>，也就是我们的第二个 <code>Context</code>，其值为 <code>"Reactor"</code>。</p>
</div>
<div class="paragraph">
<p>你可能会想知道，<code>Context</code> 是否会随着数据信号一起传播。如果是那种情况下的话，再在这两个写操作之间放置另一个 <code>flatMap</code>，那么就会使用最上面的 <code>Context</code>。但事实并未如此，下面的例子就证明了这一点：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
                     .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="2"></i><b>(2)</b>
                     .flatMap( s -&gt; Mono.subscriberContext()
                                        .map( ctx -&gt; s + " " + ctx.get(key))) <i class="conum" data-value="4"></i><b>(4)</b>
                     .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor World") <i class="conum" data-value="5"></i><b>(5)</b>
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一次写操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二次写操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第一个 <code>flatMap</code> 看到第二次写入的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个 <code>flatMap</code> 将第一次的结果与第一次写入的值连接起来。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>Mono</code> 发出 <code>"Hello Reactor World"</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>原因是 <code>Context</code> 与 <code>Subscriber</code> 相关联，每个操作符通过下游的 <code>Subscriber</code> 来请求访问 <code>Context</code>。</p>
</div>
<div class="paragraph">
<p>最后一个有趣的传播情况是将 <code>Context</code> 也被写到 <code>flatMap</code> 中，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String key = "message";
Mono&lt;String&gt; r =
        Mono.just("Hello")
            .flatMap( s -&gt; Mono.subscriberContext()
                               .map( ctx -&gt; s + " " + ctx.get(key))
            )
            .flatMap( s -&gt; Mono.subscriberContext()
                               .map( ctx -&gt; s + " " + ctx.get(key))
                               .subscriberContext(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
            )
            .subscriberContext(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello World Reactor")
            .verifyComplete();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个 <code>subscriberContext</code> 不会影响到 <code>flatMap</code> 之外的任何东西。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这个 <code>subscriberContext</code> 会影响到主序列的 <code>Context</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中，最终发出的值为 <code>"Hello World Reactor"</code> 而不是 "Hello Reactor World"，因为写 <code>"Reactor"</code> 的 <code>subscriberContext</code> 是作为第二个 <code>flatMap</code> 的内部序列的一部分。因此，它不可见或通过主序列传播，且第一个 <code>flatMap</code> 也看不到它。传播和不可变性将创建中间内部序列的操作符（例如 <code>flatMap</code>）中的 <code>Context</code> 隔离。</p>
</div>
</div>
<div class="sect3">
<h4 id="_完整的例子"><a class="anchor" href="#_完整的例子"></a>9.8.5. 完整的例子</h4>
<div class="paragraph">
<p>现在我们可以考虑一个更真实的例子，一个库从 <code>Context</code> 中读取信息：一个将 <code>Mono&lt;String&gt;</code> 作为 <code>PUT</code> 的数据源，但同时也会寻找一个特定的上下文键，以将相关的ID添加到请求头中的响应式HTTP客户端。</p>
</div>
<div class="paragraph">
<p>从用户的角度来看，调用如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">doPut("www.example.com", Mono.just("Walter"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了传播一个相关的ID，它将调用如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">doPut("www.example.com", Mono.just("Walter"))
	.subscriberContext(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>正如前面的代码片段所示，用户代码使用 <code>subscriberContext</code> 填充具有 <code>HTTP_CORRELATION_ID</code> 键值对的 <code>Context</code>。操作符的上游是由HTTP客户端库返回的 <code>Mono&lt;Tuple2&lt;Integer, String&gt;&gt;</code>（HTTP响应的简单表示）。所以它有效地将信息从用户代码传递给框架代码。</p>
</div>
<div class="paragraph">
<p>下面的例子显示了从框架角度的模拟代码，读取上下文，找到相关ID并 &#8220;构造请求&#8221;。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static final String HTTP_CORRELATION_ID = "reactive.http.library.correlationId";

Mono&lt;Tuple2&lt;Integer, String&gt;&gt; doPut(String url, Mono&lt;String&gt; data) {
	Mono&lt;Tuple2&lt;String, Optional&lt;Object&gt;&gt;&gt; dataAndContext =
			data.zipWith(Mono.subscriberContext() <i class="conum" data-value="1"></i><b>(1)</b>
			                 .map(c -&gt; c.getOrEmpty(HTTP_CORRELATION_ID))); <i class="conum" data-value="2"></i><b>(2)</b>

	return dataAndContext
			.&lt;String&gt;handle((dac, sink) -&gt; {
				if (dac.getT2().isPresent()) { <i class="conum" data-value="3"></i><b>(3)</b>
					sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url + " with header X-Correlation-ID = " + dac.getT2().get());
				}
				else {
					sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url);
				}
				sink.complete();
			})
			.map(msg -&gt; Tuples.of(200, msg));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通过 <code>Mono.subscriberContext()</code> 具体化 <code>Context</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>提取相关ID键的值，作为 <code>Optional</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果键存在于上下文中，则使用相关的ID作为头。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>框架代码段用 <code>Mono.subscriberContext()</code> 压缩数据 <code>Mono</code>。为框架提供了 <code>Tuple2&lt;String, Context&gt;</code>，并且上下文中包含了来自下游（因为它位于直接订阅的路径）的 <code>HTTP_CORRELATION_ID</code> 条目。</p>
</div>
<div class="paragraph">
<p>然后，框架代码使用 <code>map</code> 提取该键的 <code>Optional&lt;String&gt;</code>，如果该条目存在，它将传递的相关ID作为 <code>X-Correlation-ID</code> 头。这最后一部分由 <code>handle</code> 模拟。</p>
</div>
<div class="paragraph">
<p>整个验证框架代码使用的相关ID的整个测试可以写成如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Test
public void contextForLibraryReactivePut() {
	Mono&lt;String&gt; put = doPut("www.example.com", Mono.just("Walter"))
			.subscriberContext(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))
			.filter(t -&gt; t.getT1() &lt; 300)
			.map(Tuple2::getT2);

	StepVerifier.create(put)
	            .expectNext("PUT &lt;Walter&gt; sent to www.example.com with header X-Correlation-ID = 2-j3r9afaf92j-afkaf")
	            .verifyComplete();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>9.9. 处理需要清理的对象</h3>
<div class="paragraph">
<p>在非常特殊的情况下，你的应用程序可能会处理那些一旦不再使用就需要某种形式清理的类型。这是一个高级的场景&#8201;&#8212;&#8201;例如，当有引用计数对象或处理堆外对象时。Netty的 <code>ByteBuf</code> 就是一个很好的例子。</p>
</div>
<div class="paragraph">
<p>为了确保对此类对象进行正确的清理，你需要基于 <code>Flux</code>-by-<code>Flux</code> 以及在几个全局钩子（参考 <a href="#hooks">使用全局钩子</a>）中对其进行说明：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>doOnDiscard</code> <code>Flux</code>/<code>Mono</code> 操作符</p>
</li>
<li>
<p><code>onOperatorError</code> 钩子</p>
</li>
<li>
<p><code>onNextDropped</code> 钩子</p>
</li>
<li>
<p>操作符特定的处理器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是必要的，因为每个钩子都考虑到了特定的清理子集，用户可能希望（例如）除了在 <code>onOperatorError</code> 中的清理逻辑之外，还需要实现特定的错误处理逻辑。</p>
</div>
<div class="paragraph">
<p>注意，有些操作符不太适合处理需要清理的对象。例如，<code>bufferWhen</code> 可以引入重叠的缓冲区，这意味着我们之前使用的已丢弃的 &#8220;本地钩子&#8221; 可能会将第一个缓冲区视为被丢弃，并清理其中的一个元素，而这个元素在第二个缓冲区中仍然有效。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
为了便于清理，<strong>所有这些钩子必须是幂等的</strong>。在某些情况下，它们可能会被多次应用于同一对象。与执行类级别 <code>instanceOf</code> 检测的 <code>doOnDiscard</code> 操作符不同，全局的钩子处理的实例可以是任何 <code>Object</code>。区分哪些实例需要清理和不需要清理，取决于用户的实现。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_doondiscard_操作符_或者本地钩子"><a class="anchor" href="#_doondiscard_操作符_或者本地钩子"></a>9.9.1. <code>doOnDiscard</code> 操作符 或者本地钩子</h4>
<div class="paragraph">
<p>该钩子专门用于清理那些永远不会被用户代码暴露的对象。它旨在用于在正常情况下运行的流（而不是推送很多元素且被 <code>onNextDropped</code> 覆盖的错误的源）的清理钩子。</p>
</div>
<div class="paragraph">
<p>它是局部的，即它是通过操作符激活的，并且仅应用于给定的 <code>Flux</code> 或者 <code>Mono</code>。</p>
</div>
<div class="paragraph">
<p>很明显的情况包括从上游过滤元素的操作符。这些元素永远不会到达下一个操作符（或最终订阅者），但这是正常执行途经的一部分。因此，它们被传递到 <code>doOnDiscard</code> 钩子。你可能使用 <code>doOnDiscard</code> 钩子的例子包括以下情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter</code>： 不符合过滤器的项被视为 &#8220;丢弃&#8221;。</p>
</li>
<li>
<p><code>skip</code>：跳过的项将被丢弃。</p>
</li>
<li>
<p><code>buffer(maxSize, skip)</code> 与 <code>maxSize &lt; skip</code>：&#8220;丢弃的缓冲区&#8221;&#8201;&#8212;&#8201;缓冲区之间的元素被丢弃。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但 <code>doOnDiscard</code> 并不局限于过滤操作符，而且还被用于在内部对数据进行排队以达到背压目的的操作符。更具体地说，在大多数情况下，这在取消过程中很重要。从源中预先提取数据，然后按需发布到订阅者的操作符可能在被取消时还未发出数据。这样的操作符使用 <code>doOnDiscard</code> 钩子在取消时清理它们内部的背压 <code>队列</code>。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>doOnDiscard(Class, Consumer)</code> 的每次调用都是与其它操作符一起的，以使其只能被其上游的操作符看到并使用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_onoperatorerror_钩子"><a class="anchor" href="#_onoperatorerror_钩子"></a>9.9.2. <code>onOperatorError</code> 钩子</h4>
<div class="paragraph">
<p><code>onOperatorError</code> 钩子旨在以横向的方式修改错误（类似于AOP的捕获和重新抛出异常）。</p>
</div>
<div class="paragraph">
<p>当在处理 <code>onNext</code> 信号期间发生错误时，将要发出的元素被传递给 <code>onOperatorError</code>。</p>
</div>
<div class="paragraph">
<p>如果这种类型的元素需要清理，则需要在 <code>onOperatorError</code> 钩子中实现它，可能是在重写错误代码之上。</p>
</div>
</div>
<div class="sect3">
<h4 id="_onnextdropped_钩子"><a class="anchor" href="#_onnextdropped_钩子"></a>9.9.3. <code>onNextDropped</code> 钩子</h4>
<div class="paragraph">
<p>对于格式不正确的 <code>Publishers</code>，在某些情况下，操作符可能在预期没有元素的情况下（通常是在收到 <code>onError</code> 或 <code>onComplete</code> 信号之后）接收到一个元素。在这种情况下，不期望的元素是 &#8220;删除的&#8221;&#8201;&#8212;&#8201;即传递给 <code>onNextDropped</code> 钩子。如果你有需要清理的类型，则必须在 <code>onNextDropped</code> 钩子中检测到这些类型，并在那里实现清理代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_操作符特定的处理器"><a class="anchor" href="#_操作符特定的处理器"></a>9.9.4. 操作符特定的处理器</h4>
<div class="paragraph">
<p>一些处理缓冲区或将收集值作为其操作的一部分的操作符，有着特定的处理器，以处理所收集的数据不向下游传播的情况。如果你使用的此类操作符的类型需要清理，则需要在这些处理器中执行清理。</p>
</div>
<div class="paragraph">
<p>例如，<code>distinct</code> 有这样一个回调，在操作符终止（或取消）时调用该回调函数，以便清除用于判断元素是否不同的集合。默认情况下，集合是一个 <code>HashSet</code>，清理的回调函数为 <code>HashSet::clear</code>。但是，如果处理的是引用计数的对象，你可能想把它更改为一个更复杂的处理器，能够在调用 <code>clear()</code> 之前 <code>release</code> 集合中的每个元素。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="null-safety"><a class="anchor" href="#null-safety"></a>9.10. 空安全</h3>
<div class="paragraph">
<p>尽管Java不允许在其类型系统中表示null安全，但Reactor现在提供了注解来声明API的可空性，类似与Spring5提供的注解。</p>
</div>
<div class="paragraph">
<p>Reactor使用这些注解，但是它们也可以用于任何基于Reactor的Java项目中来声明可空的API。方法体内使用的类型的可空性不在此功能范围之内。</p>
</div>
<div class="paragraph">
<p>这些注解是用 <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> 进行元注解(一种被IntelliJ IDEA之类的工具支持的潜在JSR)，为Java开发人员提供与空安全相关的有用的警告，以避免运行时出现 <code>NullPointerException</code>。JSR 305 元注解允许IDE厂商以通用的方式提供空安全支持，而不必为Reactor注解提供硬编码支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在Kotlin 1.1.5+ 中，不需要也不建议在你的项目类路径下依赖 JSR 305。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>它们也被Kotlin使用，Kotlin原生支持 <a href="https://kotlinlang.org/docs/reference/null-safety.html">空安全</a>。请看 <a href="#kotlin-null-safety">这一节</a> 了解更多详细信息。</p>
</div>
<div class="paragraph">
<p><code>reactor.util.annotation</code> 包中提供了以下注解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNull.html"><code>@NonNull</code></a>：表示特定的参数，返回值或字段不能为 <code>null</code>。（在使用 <code>@NonNullApi</code> 的参数和返回值上不需要它）。</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/Nullable.html"><code>@Nullable</code></a>：表示参数，返回值或字段可以为 <code>null</code>。</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNullApi.html"><code>@NonNullApi</code></a>：表示参数和返回值默认为非空的包级别注解。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
尚不支持泛型类型参数，变量参数和数组元素的可空性。请看 <a href="https://github.com/reactor/reactor-core/issues/878">issue #878</a> 获取最新信息。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/advancedFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#advanced">高级特性和概念</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="which-operator"><a class="anchor" href="#which-operator"></a>Appendix A: 我需要哪个操作符？</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在本节中，如果一个操作符是针对 <code>Flux</code> 或 <code>Mono</code>，它会相应地加上前缀。普通的操作符是没有前缀的。当一个特定的用例被操作符组合覆盖时，它以方法调用的形式呈现，在括号中加上前导点和参数，如下所示：<code>.methodCall(parameter)</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我想处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#which.create">创建一个新的序列&#8230;&#8203;</a></p>
</li>
<li>
<p><a href="#which.values">转换已有的序列</a></p>
</li>
<li>
<p><a href="#which.filtering">过滤序列</a></p>
</li>
<li>
<p><a href="#which.peeking">探测序列</a></p>
</li>
<li>
<p><a href="#which.errors">处理错误</a></p>
</li>
<li>
<p><a href="#which.time">与时间的合作</a></p>
</li>
<li>
<p><a href="#which.window">拆分 <code>Flux</code></a></p>
</li>
<li>
<p><a href="#which.blocking">回到同步的世界</a></p>
</li>
<li>
<p><a href="#which.multicasting">广播 <code>Flux</code> 到多个 <code>Subscribers</code></a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="which.create"><a class="anchor" href="#which.create"></a>A.1. 创建一个新的序列&#8230;&#8203;</h3>
<div class="ulist">
<ul>
<li>
<p>发出 <code>T</code>，且我已经有了这个值：<code>just</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;来自 <code>Optional&lt;T&gt;</code>：<code>Mono#justOrEmpty(Optional&lt;T&gt;)</code></p>
</li>
<li>
<p>&#8230;&#8203;从可能为`空` T：<code>Mono#justOrEmpty(T)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>发出一个由方法返回的 <code>T</code>：也是 <code>just</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;延迟获取：使用 <code>Mono#fromSupplier</code> 或在 <code>defer</code> 中包装 <code>just</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>发出几个 <code>T</code>，可以明确地列举：<code>Flux#just(T&#8230;&#8203;)</code></p>
</li>
<li>
<p>迭代：</p>
<div class="ulist">
<ul>
<li>
<p>数组：<code>Flux#fromArray</code></p>
</li>
<li>
<p>集合或可迭代：<code>Flux#fromIterable</code></p>
</li>
<li>
<p>整数范围：<code>Flux#range</code></p>
</li>
<li>
<p>为每个订阅提供了一个 <code>流</code>：<code>Flux#fromStream(Supplier&lt;Stream&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>从各种单值源发出的，例如：</p>
<div class="ulist">
<ul>
<li>
<p>一个 <code>Supplier&lt;T&gt;</code>：<code>Mono#fromSupplier</code></p>
</li>
<li>
<p>任务：<code>Mono#fromCallable</code>，<code>Mono#fromRunnable</code></p>
</li>
<li>
<p>一个 <code>CompletableFuture&lt;T&gt;</code>：<code>Mono#fromFuture</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>完成：<code>empty</code></p>
</li>
<li>
<p>立即出错：<code>error</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;延迟构建 <code>Throwable</code>：<code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>不做任何事情：<code>never</code></p>
</li>
<li>
<p>在订阅时决定：<code>defer</code></p>
</li>
<li>
<p>依赖于一次性资源：<code>using</code></p>
</li>
<li>
<p>以编程的方式生成事件（可以使用状态）：</p>
<div class="ulist">
<ul>
<li>
<p>同步逐个生成：<code>Flux#generate</code></p>
</li>
<li>
<p>异步（也可以同步），可以一次发射多个信号：<code>Flux#create</code>（<code>Mono#create</code> 没有发射多个信号的特性）</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.values"><a class="anchor" href="#which.values"></a>A.2. 转换已有的序列</h3>
<div class="ulist">
<ul>
<li>
<p>我想转换已有的数据：</p>
<div class="ulist">
<ul>
<li>
<p>按一对一（如字符串的长度）：<code>map</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;通过映射：<code>cast</code></p>
</li>
<li>
<p>&#8230;&#8203;为了实现每个源值的索引：<code>Flux#index</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>在1对n的基础上（如字符串到其字符）：<code>flatMap</code> + 使用一个工厂方法</p>
</li>
<li>
<p>在1对n的基础上，对每个源元素和/或状态提供编程行为：<code>handle</code></p>
</li>
<li>
<p>为每个源条目（如,url到http请求）执行一个异步任务：<code>flatMap</code> + 一个异步的 <code>Publisher</code> 返回方法</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;忽略一些数据：在flatMap lambda中有条件地返回一个 <code>Mono.empty()</code></p>
</li>
<li>
<p>&#8230;&#8203;保留原始序列的顺序：<code>Flux#flatMapSequential</code>（这会立即触发异步处理，并重新排序结果）</p>
</li>
<li>
<p>&#8230;&#8203;异步任务可以从一个 <code>Mono</code> 源返回多个值：<code>Mono#flatMapMany</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想将预设元素添加到现有序列中：</p>
<div class="ulist">
<ul>
<li>
<p>在开始：<code>Flux#startWith(T&#8230;&#8203;)</code></p>
</li>
<li>
<p>在末尾：<code>Flux#concatWith(T&#8230;&#8203;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想聚合一个 <code>Flux</code>：（假设前缀为 <code>Flux#</code>）</p>
<div class="ulist">
<ul>
<li>
<p>聚合到List：<code>collectList</code>，<code>collectSortedList</code></p>
</li>
<li>
<p>聚合为Map：<code>collectMap</code>，<code>collectMultiMap</code></p>
</li>
<li>
<p>聚合到任意容器中：<code>collect</code></p>
</li>
<li>
<p>聚合为序列的大小：<code>count</code></p>
</li>
<li>
<p>通过在每个元素之间应用函数（例如，计算总和）：<code>reduce</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但发出每个中间值：<code>scan</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>从谓词聚合为布尔值：</p>
<div class="ulist">
<ul>
<li>
<p>应用于所有值（和）：<code>all</code></p>
</li>
<li>
<p>应用于至少一个值（或）：<code>any</code></p>
</li>
<li>
<p>测试是否存在任何值：<code>hasElements</code></p>
</li>
<li>
<p>测试是否存在特定值：<code>hasElement</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想组合生产者&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>按顺序：<code>Flux#concat</code> 或 <code>.concatWith(other)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;延迟任何错误，直到剩余的生产者全部发出后：<code>Flux#concatDelayError</code></p>
</li>
<li>
<p>&#8230;&#8203;马上订阅后续发布者：<code>Flux#mergeSequential</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>按发出的顺序（组合后的发出和它们来时一样）：<code>Flux#merge</code> / <code>.mergeWith(other)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;不同类型（转换合并）：<code>Flux#zip</code> / <code>Flux#zipWith</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>按配对值组合：</p>
<div class="ulist">
<ul>
<li>
<p>将两个Mono组合成一个 <code>Tuple2</code>：<code>Mono#zipWith</code></p>
</li>
<li>
<p>全部完成后从n个Mono中合并：<code>Mono#zip</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过配合它们的终止而合并：</p>
<div class="ulist">
<ul>
<li>
<p>将1个Mono和任何源合并为 <code>Mono&lt;Void&gt;</code>：<code>Mono#and</code></p>
</li>
<li>
<p>全部完成时从n个源合并：<code>Mono#when</code></p>
</li>
<li>
<p>合并为任意容器类型：</p>
<div class="ulist">
<ul>
<li>
<p>每次所有的都发出：<code>Flux#zip</code>（直到最小基数）</p>
</li>
<li>
<p>每次有新的值时：<code>Flux#combineLatest</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>只考虑先发出的序列：<code>Flux#first</code>，<code>Mono#first</code>，<code>mono.or(otherMono).or(thirdMono)</code>， <code>flux.or(otherFlux).or(thirdFlux)</code></p>
</li>
<li>
<p>由源序列中的元素触发：<code>switchMap</code>（每个源元素都映射到生产者）</p>
</li>
<li>
<p>由生产者序列中的下一个生产者开始时触发：<code>switchOnNext</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想重复一个已有序列：<code>repeat</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;每隔一段时间：<code>Flux.interval(duration).flatMap(tick &#8594; myExistingPublisher)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个空序列，但&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>我要一个值代替：<code>defaultIfEmpty</code></p>
</li>
<li>
<p>我想要另一个序列：<code>switchIfEmpty</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个序列，但我对值不感兴趣：<code>ignoreElements</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;我要想把完成的内容表示为 <code>Mono</code>：<code>then</code></p>
</li>
<li>
<p>&#8230;&#8203;我想等待另一个任务结束后再去完成：<code>thenEmpty</code></p>
</li>
<li>
<p>&#8230;&#8203;我想在结尾切换到另一个 <code>Mono</code>：<code>Mono#then(mono)</code></p>
</li>
<li>
<p>&#8230;&#8203;我想在末尾发出一个值：<code>Mono#thenReturn(T)</code></p>
</li>
<li>
<p>&#8230;&#8203;我想在最后切换到 <code>Flux</code>：<code>thenMany</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个想要延迟完成的Mono&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;直到该值的派生的另一个生产者完成为止：<code>Mono#delayUntil(Function)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想将元素递归地展开成一个序列图，并发出组合&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;首先展开图的宽度：<code>expand(Function)</code></p>
</li>
<li>
<p>&#8230;&#8203;首先展开图的深度：<code>expandDeep(Function)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.peeking"><a class="anchor" href="#which.peeking"></a>A.3. 探测序列</h3>
<div class="ulist">
<ul>
<li>
<p>在不修改最终顺序的情况下，我希望：</p>
<div class="ulist">
<ul>
<li>
<p>得到通知/执行其它行为（有时称为“副作用”）：</p>
<div class="ulist">
<ul>
<li>
<p>发出：<code>doOnNext</code></p>
</li>
<li>
<p>完成：<code>Flux#doOnComplete</code>，<code>Mono#doOnSuccess</code>（包括结果，如果有的话）</p>
</li>
<li>
<p>错误终止：<code>doOnError</code></p>
</li>
<li>
<p>取消：<code>doOnCancel</code></p>
</li>
<li>
<p>序列的“开始”：<code>doFirst</code></p>
<div class="ulist">
<ul>
<li>
<p>这与 <code>Publisher#subscribe(Subscriber)</code> 绑定的</p>
</li>
</ul>
</div>
</li>
<li>
<p>订阅后：<code>doOnSubscribe</code></p>
<div class="ulist">
<ul>
<li>
<p>如 <code>subscribe</code> 后的 <code>Subscription</code> 确认</p>
</li>
<li>
<p>这与 <code>Subscriber#onSubscribe(Subscription)</code> 绑定的</p>
</li>
</ul>
</div>
</li>
<li>
<p>请求：<code>doOnRequest</code></p>
</li>
<li>
<p>完成或错误：<code>doOnTerminate</code>（Mono包括结果，如果有的话）</p>
<div class="ulist">
<ul>
<li>
<p>但在传播到下游之 <strong>后</strong> ：<code>doAfterTerminate</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>任何类型的信号，表示为 <code>信号</code>：<code>Flux#doOnEach</code></p>
</li>
<li>
<p>任何终止条件（完成，错误，取消）：<code>doFinally</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>记录内部发生了什么：<code>log</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想知道所有的事件：</p>
<div class="ulist">
<ul>
<li>
<p>每个事件都表示为 <code>Signal</code> 对象：</p>
<div class="ulist">
<ul>
<li>
<p>在序列外的回调中：<code>doOnEach</code></p>
</li>
<li>
<p>而不是原始的onNext发出：<code>materialize</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;然后返回到onNexts：<code>dematerialize</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>作为日志中的一行：<code>log</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.filtering"><a class="anchor" href="#which.filtering"></a>A.4. 过滤序列</h3>
<div class="ulist">
<ul>
<li>
<p>我想过滤一个序列：</p>
<div class="ulist">
<ul>
<li>
<p>基于任意条件：<code>filter</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;异步计算：<code>filterWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>限制发出对象的类型：<code>ofType</code></p>
</li>
<li>
<p>完全忽略值：<code>ignoreElements</code></p>
</li>
<li>
<p>忽略重复的：</p>
<div class="ulist">
<ul>
<li>
<p>在整个序列（逻辑集合）中：<code>Flux#distinct</code></p>
</li>
<li>
<p>在后续发出的条目（重复数据删除）之间：<code>Flux#distinctUntilChanged</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我只想只保留序列的一个子集：</p>
<div class="ulist">
<ul>
<li>
<p>取N个元素</p>
<div class="ulist">
<ul>
<li>
<p>在序列的开头：<code>Flux#take(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;按时间周期：<code>Flux#take(Duration)</code></p>
</li>
<li>
<p>&#8230;&#8203;只有第一个元素作为一个 <code>Mono</code>：<code>Flux#next()</code></p>
</li>
<li>
<p>&#8230;&#8203;使用 <code>request(N)</code> 而不是取消：<code>Flux#limitRequest(long)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>在序列的末尾：<code>Flux#takeLast</code></p>
</li>
<li>
<p>直到满足条件（包括）为止：<code>Flux#takeUntil</code>（基于谓词），<code>Flux#takeUntilOther</code>（基于生产者的另外的生产者）</p>
</li>
<li>
<p>满足条件（不包括）时：<code>Flux#takeWhile</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>最多取一个元素：</p>
<div class="ulist">
<ul>
<li>
<p>在某个位置：<code>Flux#elementAt</code></p>
</li>
<li>
<p>在末尾：<code>.takeLast(1)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;如果为空则发出错误：<code>Flux#last()</code></p>
</li>
<li>
<p>&#8230;&#8203;如果为空，则发出默认值：<code>Flux#last(T)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>通过跳过元素：</p>
<div class="ulist">
<ul>
<li>
<p>在序列的开头：<code>Flux#skip(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>按时间周期：<code>Flux#skip(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>在序列的末尾：<code>Flux#skipLast</code></p>
</li>
<li>
<p>直到满足条件（包括）为止：<code>Flux#skipUntil</code>（基于谓词），<code>Flux#skipUntilOther</code>（基于生产者的另外的生产者）</p>
</li>
<li>
<p>满足条件时（不包括）：<code>Flux#skipWhile</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过采样元素：</p>
<div class="ulist">
<ul>
<li>
<p>按时间周期: <code>Flux#sample(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>将第一个元素保留在采样窗口中，而不是最后一个：<code>sampleFirst</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a publisher-based window: <code>Flux#sample(Publisher)</code></p>
</li>
<li>
<p>基于生产者窗口：<code>Flux#sample(Publisher)</code></p>
</li>
<li>
<p>基于生产者的 “超时”：<code>Flux#sampleTimeout</code>（每个元素触发一个生产者，如果该生产者与下一个不重叠则发出）</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我期望最多1个元素（如果多于一个，则会出错）&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>如果序列为空，我想要一个错误：<code>Flux#single()</code></p>
</li>
<li>
<p>如果序列为空，我想要一个默认值：<code>Flux#single(T)</code></p>
</li>
<li>
<p>我也接收空序列：<code>Flux#singleOrEmpty</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.errors"><a class="anchor" href="#which.errors"></a>A.5. 处理错误</h3>
<div class="ulist">
<ul>
<li>
<p>我想创建一个错误序列：<code>error</code>&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;替换成功完成的 <code>Flux</code>：<code>.concat(Flux.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;替换成功 <strong>发出</strong> 的 <code>Mono</code>：<code>.then(Mono.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;如果onNext之间的间隔太长：<code>timeout</code></p>
</li>
<li>
<p>&#8230;&#8203;延迟：<code>error(Supplier&lt;Throwable&gt;)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想等效于try/catch：</p>
<div class="ulist">
<ul>
<li>
<p>抛出：<code>error</code></p>
</li>
<li>
<p>捕获异常：</p>
<div class="ulist">
<ul>
<li>
<p>回退到默认值：<code>onErrorReturn</code></p>
</li>
<li>
<p>回退到另一个 <code>Flux</code> 或 <code>Mono</code>：<code>onErrorResume</code></p>
</li>
<li>
<p>包装并重新抛出：<code>.onErrorMap(t &#8594; new RuntimeException(t))</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>finally块：<code>doFinally</code></p>
</li>
<li>
<p>Java 7开始的使用方式：<code>using</code> 工厂方法</p>
</li>
</ul>
</div>
</li>
<li>
<p>我想从错误中恢复&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>通过回退：</p>
<div class="ulist">
<ul>
<li>
<p>回退到某个值：<code>onErrorReturn</code></p>
</li>
<li>
<p>回退到 <code>Publisher</code> 或 <code>Mono</code>，取决于错误的不同：<code>Flux#onErrorResume</code> 和 <code>Mono#onErrorResume</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>简单策略（最大尝试次数）：<code>retry</code>，<code>retry(long)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;由伴随的Flux触发：<code>retryWhen</code></p>
</li>
<li>
<p>&#8230;&#8203;使用标准的回退策略（带抖动的指数退避）：<code>retryWhen(Retry.backoff(&#8230;&#8203;))</code>（另见 <code>Retry</code> 中的其他工厂方法）</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想处理背压 "错误"（从上游请求最大请求量，并在下游没有产生足够多请求时应用该策略）&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>通过抛出一个特殊的 <code>IllegalStateException</code>：<code>Flux#onBackpressureError</code></p>
</li>
<li>
<p>通过丢掉多余的值：<code>Flux#onBackpressureDrop</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;除了最后一次看到的：<code>Flux#onBackpressureLatest</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过缓冲多余的值（有界或无界）：<code>Flux#onBackpressureBuffer</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;当有界缓冲区也溢出时应用这种策略：使用 <code>BufferOverflowStrategy</code> 的 <code>Flux#onBackpressureBuffer</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.time"><a class="anchor" href="#which.time"></a>A.6. 与时间的合作</h3>
<div class="ulist">
<ul>
<li>
<p>我想将发出和测量的时间（<code>Tuple2&lt;Long, T&gt;</code>）相关联&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>自订阅开始：<code>elapsed</code></p>
</li>
<li>
<p>自始至今（计算机时间）：<code>timestamp</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>如果在两次发出之间有太多的延迟，我希望序列被中断：<code>timeout</code></p>
</li>
<li>
<p>我想得到以固定时间间隔的时钟周期：<code>Flux#interval</code></p>
</li>
<li>
<p>我想在初始延迟后发出一个 <code>0</code>：静态的 <code>Mono.delay</code></p>
</li>
<li>
<p>我想引入延迟：</p>
<div class="ulist">
<ul>
<li>
<p>在每个onNext信号之间：<code>Mono#delayElement</code>，<code>Flux#delayElements</code></p>
</li>
<li>
<p>在订阅前发生：<code>delaySubscription</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.window"><a class="anchor" href="#which.window"></a>A.7. 拆分 <code>Flux</code></h3>
<div class="ulist">
<ul>
<li>
<p>我想按一个边界条件把 <code>Flux&lt;T&gt;</code> 拆分成 <code>Flux&lt;Flux&lt;T&gt;&gt;</code>：</p>
<div class="ulist">
<ul>
<li>
<p>大小：<code>window(int)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;重叠或下降的窗口：<code>window(int, int)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>时间：<code>window(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;重叠或下降的窗口：<code>window(Duration, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>大小或时间（达到计数或者超时后窗口关闭）：<code>windowTimeout(int, Duration)</code></p>
</li>
<li>
<p>按元素上的谓词：<code>windowUntil</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;在下一个窗口中（<code>cutBefore</code> 形式）发出触发边界的元素：<code>.windowUntil(predicate, true)</code></p>
</li>
<li>
<p>&#8230;&#8203;当元素匹配谓词时保持窗口打开：<code>windowWhile</code>（不匹配的元素不被发出）</p>
</li>
</ul>
</div>
</li>
<li>
<p>由控件生产者中的onNext表示的任意边界驱动：<code>window(Publisher)</code>，<code>windowWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想把 <code>Flux&lt;T&gt;</code> 和边界内的缓冲元素拆分在一起&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>分成 <code>List</code>:</p>
<div class="ulist">
<ul>
<li>
<p>通过大小边界：<code>buffer(int)</code></p>
<div class="ulist">
<ul>
<li>
<p>缓冲区重叠或下降：<code>buffer(int, int)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过持续时间边界：<code>buffer(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;缓冲区重叠或下降：<code>buffer(Duration, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过大小或时间边界：<code>bufferTimeout(int, Duration)</code></p>
</li>
<li>
<p>通过任意条件边界：<code>bufferUntil(Predicate)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;将触发边界的元素放到下一个缓冲区中：<code>.bufferUntil(predicate, true)</code></p>
</li>
<li>
<p>&#8230;&#8203;在谓词匹配时进行缓冲，并删除触发边界的元素：<code>bufferWhile(Predicate)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>由控件生产者中的onNext表示的任意边界驱动：<code>buffer(Publisher)</code>，<code>bufferWhen</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>拆分成任意 “集合” 类型 <code>C</code>：使用类似 <code>buffer(int, Supplier&lt;C&gt;)</code> 的形式</p>
</li>
</ul>
</div>
</li>
<li>
<p>我想分割一个 <code>Flux&lt;T&gt;</code>，以便有相同特征的元素可以在同一个子flux中：<code>groupBy(Function&lt;T,K&gt;)</code>
TIP: 注意，这将返回一个 <code>Flux&lt;GroupedFlux&lt;K, T&gt;&gt;</code>，每个内部的 <code>GroupedFlux</code> 共享相同的 <code>K</code> 键，并可通过 <code>key()</code> 访问。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.blocking"><a class="anchor" href="#which.blocking"></a>A.8. 回到同步的世界</h3>
<div class="paragraph">
<p>注意：如果从在标记为 "仅非阻塞"（默认 <code>parallel()</code> 和 <code>single()</code> ） 的 <code>Scheduler</code> 调用，则除了 <code>Mono#toFuture</code> 之外的所有这些方法都会抛出一个 <code>UnsupportedOperatorException</code> 异常。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我有一个 <code>Flux&lt;T&gt;</code>，我希望：</p>
<div class="ulist">
<ul>
<li>
<p>阻塞到我得到一个一个元素为止：<code>Flux#blockFirst</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;超时阻塞：<code>Flux#blockFirst(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>阻塞到我得到最后一个元素为止（如果为空，则返回null）：<code>Flux#blockLast</code></p>
<div class="ulist">
<ul>
<li>
<p>超时阻塞：<code>Flux#blockLast(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>同步切换到 <code>Iterable&lt;T&gt;</code>：<code>Flux#toIterable</code></p>
</li>
<li>
<p>同步切换到Java 8 <code>Stream&lt;T&gt;</code>：<code>Flux#toStream</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个 <code>Mono&lt;T&gt;</code>，我希望：</p>
<div class="ulist">
<ul>
<li>
<p>阻塞到我获取到值为止：<code>Mono#block</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;超时阻塞：<code>Mono#block(Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>CompletableFuture&lt;T&gt;</code>：<code>Mono#toFuture</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.multicasting"><a class="anchor" href="#which.multicasting"></a>A.9. 广播 <code>Flux</code> 到多个 <code>Subscribers</code></h3>
<div class="ulist">
<ul>
<li>
<p>我想将多个 <code>Subscriber</code> 连接到一个 <code>Flux</code> 上：</p>
<div class="ulist">
<ul>
<li>
<p>并决定何时用 <code>connect()</code> 触发源：<code>publish()</code>（返回一个 <code>ConnectableFlux</code>）</p>
</li>
<li>
<p>并立即触发源（后面的订阅者看到随后的数据）：<code>share()</code></p>
</li>
<li>
<p>当注册了足够的订阅者后永久连接源：<code>.publish().autoConnect(n)</code></p>
</li>
<li>
<p>当订阅者高于/低于阀值时自动连接和取消源：<code>.publish().refCount(n)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但是给每个新的订阅者一个机会，让它们在取消之前有机会进来：<code>.publish().refCountGrace(n, Duration)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想缓存来自 <code>Publisher</code> 的数据并将其重新发出到以后的订阅者：</p>
<div class="ulist">
<ul>
<li>
<p>最多 <code>n</code> 个元素：<code>cache(int)</code></p>
</li>
<li>
<p>缓存在 <code>Duration</code> (生命周期) 内的看到的最新元素：<code>cache(Duration)</code></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但保留不超过 <code>n</code> 个元素：<code>cache(int, Duration)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>但没有立即触发源：<code>Flux#replay</code>（返回一个 <code>ConnectableFlux</code>）</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/apdx-operatorChoice.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#which-operator">我需要哪个操作符？</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>Appendix B: 常见问题和最佳实践，“我如何&#8230;&#8203;?”</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节涵盖以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#faq.wrap-blocking">如何包装一个同步阻塞调用？</a></p>
</li>
<li>
<p><a href="#faq.chain">我在我的 <code>Flux</code> 上使用了一个操作符，但似乎不适用。为什么会这样？</a></p>
</li>
<li>
<p><a href="#faq.monoThen">我的 <code>Mono</code> <code>zipWith</code>/<code>zipWhen</code> 从未被调用过</a></p>
</li>
<li>
<p><a href="#faq.retryWhen">如何使用 <code>retryWhen</code> 来模拟 <code>retry(3)</code>?</a></p>
</li>
<li>
<p><a href="#faq.exponentialBackoff">我如何使用 <code>retryWhen</code> 进行指数退避？</a></p>
</li>
<li>
<p><a href="#faq.thread-affinity-publishon">使用 <code>publishOn()</code> 时如何确保线程关联性？</a></p>
</li>
<li>
<p><a href="#faq.mdc">上下文日志记录的好的方式是什么？（MDC）</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="faq.wrap-blocking"><a class="anchor" href="#faq.wrap-blocking"></a>B.1. 如何包装一个同步阻塞调用？</h3>
<div class="paragraph">
<p>通常情况下，信息源是同步且阻塞的。为了在你的Reactor应用中处理这些源，使用以下方式：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Mono blockingWrapper = Mono.fromCallable(() -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    return /* make a remote synchronous call */ <i class="conum" data-value="2"></i><b>(2)</b>
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通过使用 <code>fromCallable</code> 创建新的 <code>Mono</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>返回异步阻塞资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>确保每个订阅都发生在来自 <code>Schedulers.boundedElastic()</code> 创建的一个专用的单线程worker上。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>你应该使用 <code>Mono</code>，因为源只返回一个值。你应该使用 <code>Schedulers.boundedElastic</code>，因为它会创建一个专门的线程来等待阻塞资源而不影响其它的非阻塞处理，同时还确保对可创建线程数量的限制，并且在峰值期间阻塞的任务可以排队和延迟。</p>
</div>
<div class="paragraph">
<p>注意，<code>subscribeOn</code> 并不会订阅 <code>Mono</code>。它指定了当订阅调用发生时要使用什么样的 <code>Scheduler</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.chain"><a class="anchor" href="#faq.chain"></a>B.2. 我在我的 <code>Flux</code> 上使用了一个操作符，但似乎不适用。为什么会这样？</h3>
<div class="paragraph">
<p>确保你的 <code>.subscribe()</code> 的变量已经受到你认为应该应用该变量的操作符的影响。</p>
</div>
<div class="paragraph">
<p>Reactor操作符就是修饰符。它们返回不同的实例来包装源序列并添加了行为。这就是为什么使用操作符的首选方式是 <em>链接</em> 调用。</p>
</div>
<div class="paragraph">
<p>比较以下两个例子：</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 没有链接 (不正确)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux.map(secret -&gt; secret.replaceAll(".", "*")); <i class="conum" data-value="1"></i><b>(1)</b>
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>错误就出在这里。结果没有附加到 <code>flux</code> 变量。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 26. 没有链接 (正确)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux = flux.map(secret -&gt; secret.replaceAll(".", "*"));
flux.subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子就更好了（因为比较简单）：</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 使用链接 (最佳)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Flux&lt;String&gt; secrets = Flux
  .just("something", "chain")
  .map(secret -&gt; secret.replaceAll(".", "*"))
  .subscribe(next -&gt; System.out.println("Received: " + next));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个版本输出如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Received: something
Received: chain</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>其它两个版本输出的预期值，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Received: *********
Received: *****</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.monoThen"><a class="anchor" href="#faq.monoThen"></a>B.3. 我的 <code>Mono</code> <code>zipWith</code>/<code>zipWhen</code> 从未被调用过</h3>
<div class="paragraph">
<p>请看下面的例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">myMethod.process("a") // this method returns Mono&lt;Void&gt;
        .zipWith(myMethod.process("b"), combinator) //this is never called
        .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果源 <code>Mono</code> 为 <code>空</code> 或 <code>Mono&lt;Void&gt;</code>（无论出于何种目的，<code>Mono&lt;Void&gt;</code> 都是空的），则某些组合永远不会被调用。</p>
</div>
<div class="paragraph">
<p>对于诸如 <code>zip</code> 静态方法或 <code>zipWith</code>、<code>zipWhen</code> 操作符之类的任何转换器来说都是典型的情况，它们（根据定义）需要从每个源中获取一个元素来生成其输出。</p>
</div>
<div class="paragraph">
<p>因此，在 <code>zip</code> 源上使用数据抑制操作符是有问题的。数据抑制操作符的例子包括 <code>then()</code>，<code>thenEmpty(Publisher&lt;Void&gt;)</code>，<code>ignoreElements()</code> 和 <code>ignoreElement()</code>，以及 <code>when(Publisher&#8230;&#8203;)</code>。</p>
</div>
<div class="paragraph">
<p>同样，使用 <code>Function&lt;T,?&gt;</code> 来调整它们行为的操作符，例如 <code>flatMap</code>，至少需要发出一个元素，以便于 <code>Function</code> 有机会应用。将这些应用于空（或 <code>&lt;Void&gt;</code>）序列，则永远不会产生一个元素。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.defaultIfEmpty(T)</code> 和 <code>.switchIfEmpty(Publisher&lt;T&gt;)</code> 将空的 <code>T</code> 序列分别替换为默认值或回退的 <code>Publisher&lt;T&gt;</code>，这有助于避免某些情况。注意，这并不适用于 <code>Flux&lt;Void&gt;</code>/<code>Mono&lt;Void&gt;</code> 源，因为你只能切换到另一个 <code>Publisher&lt;Void&gt;</code>，它仍然保证是空的。下面的例子使用了 <code>defaultIfEmpty</code>：</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. 在 <code>zipWhen</code> 之前使用 <code>defaultIfEmpty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">myMethod.emptySequenceForKey("a") // this method returns empty Mono&lt;String&gt;
        .defaultIfEmpty("") // this converts empty sequence to just the empty String
        .zipWhen(aString -&gt; myMethod.process("b")) //this is called with the empty String
        .subscribe();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.retryWhen"><a class="anchor" href="#faq.retryWhen"></a>B.4. 如何使用 <code>retryWhen</code> 来模拟 <code>retry(3)</code>?</h3>
<div class="paragraph">
<p><code>retryWhen</code> 操作符可能相当复杂。希望下面的代码片段可以通过尝试模拟一个简单的 <code>retry(3)</code> 来帮助你理解它是如何工作的：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
		Flux.&lt;String&gt;error(new IllegalArgumentException())
				.doOnError(e -&gt; errorCount.incrementAndGet())
				.retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
						companion.map(rs -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
							if (rs.totalRetries() &lt; 3) return rs.totalRetries(); <i class="conum" data-value="3"></i><b>(3)</b>
							else throw Exceptions.propagate(rs.failure()); <i class="conum" data-value="4"></i><b>(4)</b>
						})
				));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们通过改编 <code>Function</code> lambda来自定义 <code>Retry</code>，而不是提供一个具体的类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>伴随的对象发出 <code>RetrySignal</code>，它记录了迄今为止的重试次数和最后一次失败的次数。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>为了允许三次重试，我们考虑索引&lt;3并返回一个值来发出（这里我们简单地返回索引）。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>为了在错误中终止序列，我们在这三次重试之后抛出原始异常。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.exponentialBackoff"><a class="anchor" href="#faq.exponentialBackoff"></a>B.5. 我如何使用 <code>retryWhen</code> 进行指数退避？</h3>
<div class="paragraph">
<p>指数退避会产生重新尝试，每次尝试之间的延迟会越来越长，这样就不会使源系统过载，也不会有全面崩溃的风险。理由是，如果源产生错误，它已经处于一个不稳定的状态，不太可能立即从错误中恢复过来。因此，盲目的立即重试可能会产生另一个错误，增加不稳定因素。</p>
</div>
<div class="paragraph">
<p>自从 <code>3.3.4.RELEASE</code> 之后，Reactor自带了一个用于重试的构建器，可与 <code>Flux#retryWhen</code> 一起使用：<code>Retry.backoff</code>。</p>
</div>
<div class="paragraph">
<p>下面的例子演示了一个简单的构建器的使用，在重试尝试延迟前后的钩子记录消息。它可以延迟重试并增加每次尝试之间的延迟（伪代码：延迟 = 尝试次数 * 100毫秒）：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalStateException("boom"))
		.doOnError(e -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
			errorCount.incrementAndGet();
			System.out.println(e + " at " + LocalTime.now());
		})
		.retryWhen(Retry
				.backoff(3, Duration.ofMillis(100)).jitter(0d) <i class="conum" data-value="2"></i><b>(2)</b>
				.doAfterRetry(rs -&gt; System.out.println("retried at " + LocalTime.now())) <i class="conum" data-value="3"></i><b>(3)</b>
				.onRetryExhaustedThrow((spec, rs) -&gt; rs.failure()) <i class="conum" data-value="4"></i><b>(4)</b>
		);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们将记录源发出的错误时间，并对其进行统计。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们配置了一个指数退避重试，最多尝试3次，没有抖动。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们还记录了重试发生的时间。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>默认情况下，会抛出一个 <code>Exceptions.retryExhausted</code> 异常，最后一个 <code>failure()</code> 作为失败原因。这里我们将其自定义为直接以 <code>onError</code> 的形式发出原因。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>订阅后，它将失败并在打印出以下内容后终止：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalArgumentException at 18:02:29.338
retried at 18:02:29.459 <i class="conum" data-value="1"></i><b>(1)</b>
java.lang.IllegalArgumentException at 18:02:29.460
retried at 18:02:29.663 <i class="conum" data-value="2"></i><b>(2)</b>
java.lang.IllegalArgumentException at 18:02:29.663
retried at 18:02:29.964 <i class="conum" data-value="3"></i><b>(3)</b>
java.lang.IllegalArgumentException at 18:02:29.964</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>约100毫秒后第一次重试</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>约200毫秒后第二次重试</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>约300毫秒后第三次重试</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.thread-affinity-publishon"><a class="anchor" href="#faq.thread-affinity-publishon"></a>B.6. 使用 <code>publishOn()</code> 时如何确保线程关联性？</h3>
<div class="paragraph">
<p>如 <a href="#schedulers">调度器</a> 中所描述的，<code>publishOn()</code> 可以用来切换执行上下文。<code>publishOn()</code> 操作符会影响到线程上下文，在它下面的链中的其它操作符都会在这个上下文中运行，直到出现一个新的 <code>publishOn</code>。因此，<code>publishOn</code> 的位置很重要。</p>
</div>
<div class="paragraph">
<p>请看下面的例子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">EmitterProcessor&lt;Integer&gt; processor = EmitterProcessor.create();
processor.publishOn(scheduler1)
         .map(i -&gt; transform(i))
         .publishOn(scheduler2)
         .doOnNext(i -&gt; processNext(i))
         .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>map()</code> 中的 <code>transform</code> 函数在 <code>scheduler1</code> 的工作进程上运行，<code>doOnNext()</code> 中的 <code>processNext</code> 方法运行在 <code>scheduler2</code> 的工作进程上。每个订阅都有自己的工作进程，因此，推送到相应订阅者的所有元素都是在在同一个 <code>Thread</code> 上发布。</p>
</div>
<div class="paragraph">
<p>你可以使用单线程调度器来确保在链上不同阶段或不同订阅者的线程关联性。</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.mdc"><a class="anchor" href="#faq.mdc"></a>B.7. 上下文日志记录的好的方式是什么？（MDC）</h3>
<div class="paragraph">
<p>大多数日志框架都允许进行上下文日志记录，允许用户存储反映在日志模式中的变量，通常是通过叫做MDC（“映射诊断上下文”）的 <code>Map</code> 的方式来。这是Java中 <code>ThreadLocal</code> 最常见的用法之一，因此，此模式假设所记录的代码与 <code>Thread</code> 是一对一的关系。</p>
</div>
<div class="paragraph">
<p>在Java 8之前，这可能是一个安全的假设，但随着Java语言中函数式编程元素的出现，情况发生了一些变化&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>让我们以一个命令式API的示例为例，该API使用了模版方法模式，然后切换为一个更具有函数式风格的。使用模版方法模式，继承发挥了作用。现在，在更为函数式的方法中，传递高阶函数来定义算法的“步骤”。现在的东西更多的是声明性的而不是命令式的，这使得库可以自由地决定每个步骤应该在哪里运行。例如，知道了哪些步骤的底层算法可以并行化，库就可以使用 <code>ExecutorService</code> 并行地执行某些步骤。</p>
</div>
<div class="paragraph">
<p>这种函数式API的一个具体例子是Java 8中引入的 <code>Stream</code> 及其 <code>parallel()</code> 风格。在并行 <code>Stream</code> 中使用MDC进行日志记录并不是免费的午餐：需要确保MDC在每个步骤中都能被捕获并重新应用。</p>
</div>
<div class="paragraph">
<p>函数式风格支持这样的优化，因为每个步骤都是线程不可知的和引用透明的，但是它可以打破MDC对单一 <code>Thread</code> 的假设。确保所有阶段都可以访问任何类型的上下文信息的最惯用的方法是通过组合链传递上下文。在Reactor开发过程中，我们遇到了同一类的问题，我们希望避免这种简单明了的方法。这就是引入 <code>Context</code> 的原因：只要使用 <code>Flux</code> 和 <code>Mono</code> 作为返回值，它就会通过执行链传播，让阶段（操作符）探测到其下游阶段的 <code>Context</code>。因此，Reactor中没有使用 <code>ThreadLocal</code>，而是提供了这个类似于map的对象，它绑定到一个 <code>Subscription</code> 而不是 <code>Thread</code>。</p>
</div>
<div class="paragraph">
<p>既然我们已经认定了MDC “只是在工作”，并不是在声明性API做出的最佳假设，那么我们如何在响应式流中的事件（<code>onNext</code>，<code>onError</code> 和 <code>onComplete</code>）执行与事件相关的上下文日志记录语句？</p>
</div>
<div class="paragraph">
<p>当想要以直接和明确的方式记录与这些信号的关系时，FAQ的这个条目提供了一个可能的中间解决方案。请确保事先阅读 <a href="#context">为响应式序列添加上下文</a> 章节，尤其是如何在操作符链的底部进行写操作，以使其让上方的操作符能看到。</p>
</div>
<div class="paragraph">
<p>要从 <code>Context</code> 获取上下文信息到MDC中，最简单的方式是使用一些样板代码将日志记录语句封装在一个 <code>doOnEach</code> 操作符中。该样板代码取决于你选择的日志框架/抽象和要放入MDC中的信息，因此它必须位于你的代码库中。</p>
</div>
<div class="paragraph">
<p>下面是这样一个围绕单个MDC变量的辅助函数的例子，并着重于使用Java9增强的 <code>Optional</code> API记录 <code>onNext</code> 事件：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static &lt;T&gt; Consumer&lt;Signal&lt;T&gt;&gt; logOnNext(Consumer&lt;T&gt; logStatement) {
	return signal -&gt; {
		if (!signal.isOnNext()) return; <i class="conum" data-value="1"></i><b>(1)</b>
		Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY"); <i class="conum" data-value="2"></i><b>(2)</b>

		toPutInMdc.ifPresentOrElse(tpim -&gt; {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) { <i class="conum" data-value="3"></i><b>(3)</b>
				logStatement.accept(signal.get()); <i class="conum" data-value="4"></i><b>(4)</b>
			}
		},
		() -&gt; logStatement.accept(signal.get())); <i class="conum" data-value="5"></i><b>(5)</b>
	};
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doOnEach</code> 信号包括 <code>onComplete</code> 和 <code>onError</code>。在这个例子中，我们只对记录 <code>onNext</code> 感兴趣</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们将从Reactor的 <code>Context</code>（看 <a href="#context.api"><code>Context</code> API</a> 章节） 提取一个有趣的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在这个例子中，我们使用SLF4J 2中的 <code>MDCCloseable</code>，允许使用try-with-resource语法在执行日志语句后自动清理MDC。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>调用方以 <code>Consumer&lt;T&gt;</code>（onNext值的消费者）的形式提供正确的日志语句</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果在 <code>Context</code> 中没有设置预期的键，则使用另一种方式，MDC中不放置任何东西</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>使用这个样板代码可以确保我们是MDC的良好公民：我们在执行日志记录语句之前就设置了一个键，并在执行完之后立即将其删除。在后续的日志记录语句中，不会有污染MDC的风险。</p>
</div>
<div class="paragraph">
<p>当然，这只是一个建议。你可能对从 <code>Context</code> 获取多个值或在出现 <code>onError</code> 情况时记录一些事情更感兴趣。你可能想要为这些情况创建其它辅助方法，或者创建一个使用额外的lambda来覆盖更多领域的方法。</p>
</div>
<div class="paragraph">
<p>在任何情况下：前面的辅助方法的使用都可能类似于下面的响应式web控制器：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId; <i class="conum" data-value="1"></i><b>(1)</b>

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(r -&gt; LOG.debug("found restaurant {} for ${}", <i class="conum" data-value="2"></i><b>(2)</b>
					r.getName(), r.getPricePerPerson())))
			   .subscriberContext(Context.of("CONTEXT_KEY", apiId)); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们需要从请求头中获取上下文信息，将其放入到 <code>Context</code> 中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在这里，我们使用 <code>doOnEach</code> 将我们的辅助方法应用到 <code>Flux</code> 中。记住：操作符可以看到在它们下面定义的 <code>Context</code> 值。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们使用选择的键 <code>CONTEXT_KEY</code> 将请求头中的值写入到 <code>Context</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种配置中，<code>restaurantService</code> 可以在一个共享线程上发出数据，但日志仍能为每个请求引用正确的 <code>X-UserId</code>。</p>
</div>
<div class="paragraph">
<p>为了完整起见，我们还可以看到错误日志记录的辅助方法看起来像：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static Consumer&lt;Signal&lt;?&gt;&gt; logOnError(Consumer&lt;Throwable&gt; errorLogStatement) {
	return signal -&gt; {
		if (!signal.isOnError()) return;
		Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY");

		toPutInMdc.ifPresentOrElse(tpim -&gt; {
			try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) {
				errorLogStatement.accept(signal.getThrowable());
			}
		},
		() -&gt; errorLogStatement.accept(signal.getThrowable()));
	};
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了我们检查 <code>Signal</code> 是否是一个 <code>onError</code> 以及我们向日志语句lambda提供这个错误（<code>Throwable</code>）之外，没有什么变化。</p>
</div>
<div class="paragraph">
<p>在控制器中应用这个辅助方法和我们之前做的非常相似：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
	String apiId = userId == null ? "" : userId;

	return restaurantService.byPrice(maxPrice))
			   .doOnEach(logOnNext(v -&gt; LOG.info("found restaurant {}", v))
			   .doOnEach(logOnError(e -&gt; LOG.error("error when searching restaurants", e)) <i class="conum" data-value="1"></i><b>(1)</b>
			   .subscriberContext(Context.of("CONTEXT_KEY", apiId));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果 <code>restaurantService</code> 发出错误，它将在这里用MDC上下文记录下来</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/faq.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#faq">常见问题和最佳实践，“我如何&#8230;&#8203;?”</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactor-extra"><a class="anchor" href="#reactor-extra"></a>Appendix C: Reactor-Extra</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对于 <code>reactor-core</code> 具有高级需求的用户，<code>reactor-extra</code> 模块包含了额外的操作符和工具集。</p>
</div>
<div class="paragraph">
<p>由于这是一个单独的组件，你需要显式地将其添加到构建中。下面的例子显示了在Gradle中如何操作：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
     compile 'io.projectreactor:reactor-core'
     compile 'io.projectreactor.addons:reactor-extra' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>除了core模块外，还需要添加extra模块。关于使用BOM时不需要指定版本的原因，其它详细信息以及在Maven中的用法，请看 <a href="#getting">入门Reactor</a>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-tuples"><a class="anchor" href="#extra-tuples"></a>C.1. <code>TupleUtils</code> 和函数式接口</h3>
<div class="paragraph">
<p><code>reactor.function</code> 包含了补充Java 8 <code>Function</code>，<code>Predicate</code> 和 <code>Consumer</code> 的函数式接口，适用于三到八个值。</p>
</div>
<div class="paragraph">
<p><code>TupleUtils</code> 提供了静态方法。这些方法充当这些函数式接口的lambda与对应的 <code>Tuple</code> 上的类似接口之间的桥梁。</p>
</div>
<div class="paragraph">
<p>这让你可以轻松地处理任何 <code>Tuple</code> 的独立部分，如下例所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.map(tuple -&gt; {
  String firstName = tuple.getT1();
  String lastName = tuple.getT2();
  String address = tuple.getT3();

  return new Customer(firstName, lastName, address);
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以将前面的例子改写如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.map(TupleUtils.function(Customer::new)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>（因为 <code>Customer</code> 构造器符合 <code>Consumer3</code> 函数式接口签名）</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-math"><a class="anchor" href="#extra-math"></a>C.2. <code>MathFlux</code> 数学操作符</h3>
<div class="paragraph">
<p><code>reactor.math</code> 包含了 <code>Flux</code> 特定版本的 <code>MathFlux</code>，提供了包括 <code>max</code>，<code>min</code>，<code>sumInt</code>，<code>averageDouble</code> 等数学操作符。</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-repeat-retry"><a class="anchor" href="#extra-repeat-retry"></a>C.3. 重复和重试工具</h3>
<div class="paragraph">
<p><code>reactor.retry</code> 包含了帮助编写 <code>Flux#repeatWhen</code> 和 <code>Flux#retryWhen</code> 函数的工具集。入口点分别是 <code>Repeat</code> 和 <code>Retry</code> 接口中的工厂方法。</p>
</div>
<div class="paragraph">
<p>你可以将这两个接口都用作为可变的构建器，并且它们可以正确的实现在对应的操作符中要使用的 <code>Function</code> 签名。</p>
</div>
<div class="paragraph">
<p>从3.2.0开始，这些工具集提供的最高级的重试策略之一也是 <code>reactor-core</code> 主要模块的一部分。<code>Flux#retryBackoff</code> 操作符可作为指数退避来使用。</p>
</div>
<div class="paragraph">
<p>从3.3.4开始，<code>Retry</code> 构建器直接在core中提供，并且有了更多的可能的定制，基于一个封装了错误之外的额外状态的 <code>RetrySignal</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-schedulers"><a class="anchor" href="#extra-schedulers"></a>C.4. 调度器</h3>
<div class="paragraph">
<p>Reactor-extra带有几个专门的调度器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ForkJoinPoolScheduler</code>（在 <code>reactor.scheduler.forkjoin</code> 包中）：使用Java的 <code>ForkJoinPool</code> 运行任务。</p>
</li>
<li>
<p><code>SwingScheduler</code>（在 <code>reactor.swing</code> 包中）：在Swing UI事件循环线程 <code>EDT</code> 中运行任务。</p>
</li>
<li>
<p><code>SwtScheduler</code>（在 <code>reactor.swing</code> 包中）：在SWT UI事件循环线程中运行任务。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/master/docs/asciidoc/apdx-reactorExtra.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#reactor-extra">Reactor-Extra</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.3.5.RELEASE<br>
Last updated 2020-02-24 01:25:04 +0800
</div>
</div>
<link rel="stylesheet" href="./highlight/styles/railscasts.min.css">
<script src="./highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>